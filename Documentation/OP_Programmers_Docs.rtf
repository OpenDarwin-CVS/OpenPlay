{\rtf1\mac\ansicpg10000\cocoartf100
{\fonttbl\f0\froman\fcharset77 Times-Bold;\f1\froman\fcharset77 Times-Roman;\f2\ftech\fcharset2 Symbol;
\f3\fmodern\fcharset77 Courier;\f4\froman\fcharset77 Times-Italic;}
{\colortbl;\red255\green255\blue255;}
\vieww15440\viewh10280\viewkind1\viewscale128
\pard\sa100\qc

\f0\b\fs48 \cf0 OpenPlay Programmer\'d5s Reference\
\pard\ql\qnatural

\f1\b0\fs20 \cf0 \U8232 \uc0 \u8232 
\fs15 Copyright \'a91997-99 Apple Computer, Inc.\U8232 \uc0 \u8232 All rights reserved\U8232 \u8232 
\fs20 \U8232 \uc0 \u8232 
\f0\b Note:
\f1\b0  \
\pard\sa100\ql\qnatural
\cf0 Please note that this is very rough documentation for OpenPlay. This document is currently a strict API reference. No examples are given indicating the way you should put the OpenPlay functions together in your program. Examples are provided in the \'d4OpenPlay Test\'d5 and \'d4MiniPlay\'d5 source code. \
\pard\ql\qnatural
\cf0 \
\
\pard\sa100\qc

\f0\b\fs48 \cf0 OpenPlay\
\pard\ql\qnatural

\f1\b0\fs20 \cf0 \
\pard\sa100\ql\qnatural
\cf0 OpenPlay, in a nutshell, is a Net Module Manager. The Net Module Manager and the individual Net Modules provide various transports for OpenPlay clients. Any product that is written to the OpenPlay client interface can work with any Net Module. To provide cross-platform connectivity OpenPlay is available for Mac OS and Windows 95. \
In the diagram below the connection between the high-level interface and the Net Module Manager is the OpenPlay client API. The connections between the Net Module Manager and the individual plug-ins represents the Net Module API (See the document \'d2Writing OpenPlay Net Modules\'d3 for more info on the Net Module specification). \
Clients may choose to talk to the Net Module Manager directly via the client interface, or through some other high-level abstraction API. \
\pard\ql\qnatural
\cf0 \
\pard\sa100\ql\qnatural
\cf0 The OpenPlay API provides five basic services:\
\pard\ql\qnatural

\f2 \cf0 \'b7	
\f1 Configuration functions\

\f2 \'b7	
\f1 Data transfer functions\

\f2 \'b7	
\f1 Enumeration functions\

\f2 \'b7	
\f1 Human interface\

\f2 \'b7	
\f1 Miscellaneous functions\
\
\pard\sa100\ql\qnatural
\cf0 This document describes all of the functions that constitute the public OpenPlay client API. \
\pard\ql\qnatural
\cf0 \
\
\pard\sa100\qc

\f0\b\fs48 \cf0 OpenPlay Data Types\
\pard\ql\qnatural

\f1\b0\fs20 \cf0 \
\pard\sa100\ql\qnatural

\f0\b\fs27 \cf0 Constants\
\pard\sa240\ql\qnatural

\f3\b0\fs15 \cf0 #define kNMNameLength 32\U8232 \uc0 \u8232 #define kNMCopyrightLen 32 
\f1\fs20 \
\pard\sa100\ql\qnatural

\f0\b\fs27 \cf0 NMUInt32\
\pard\sa240\ql\qnatural

\f1\b0\fs20 \cf0 NMUInt32 is an unsigned 32-bit field. \
\pard\sa100\ql\qnatural

\f0\b\fs27 \cf0 NMBoolean\
\pard\sa240\ql\qnatural

\f3\b0\fs15 \cf0 typedef char NMBoolean; 
\f1\fs20 \U8232 \uc0 \u8232 \U8232 \u8232 NMBoolean contains either the values zero or one. Zero indicates a state of FALSE, and one indicates a state of TRUE. \
\pard\sa100\ql\qnatural

\f0\b\fs27 \cf0 NMError\
\pard\sa240\ql\qnatural

\f3\b0\fs15 \cf0 typedef long NMError; 
\f1\fs20 \U8232 \uc0 \u8232 \U8232 \u8232 All error codes generated by OpenPlay are negative values. \
\pard\sa100\ql\qnatural

\f0\b\fs27 \cf0 NMType\
\pard\sa240\ql\qnatural

\f3\b0\fs15 \cf0 typedef unsigned long NMType; 
\f1\fs20 \U8232 \uc0 \u8232 \U8232 \u8232 NMType is a 32-bit type used to hold 4-byte tags. Tag data is comprised of the printable characters in standard 7-bit ASCII plus the space characters. Examples of NMTypes would be 
\f3\fs15 \'d4OpenPlay\'d5, \'d4OB 1\'d5, \'d4AT_2\'d5 
\f1\fs20 . \
\pard\sa100\ql\qnatural

\f0\b\fs27 \cf0 NMFlags\
\pard\sa240\ql\qnatural

\f3\b0\fs15 \cf0 typedef unsigned long NMFlags; 
\f1\fs20 \U8232 \uc0 \u8232 \U8232 \u8232 The NMFlags type is a 32-bit field which is used to hold bit-flags. \
\pard\sa100\ql\qnatural

\f0\b\fs27 \cf0 NMProtocol\
\pard\tx915\tx1831\tx2747\tx3662\tx4580\tx5495\tx6412\tx7327\tx8244\tx9160\tx10075\tx10990\tx11908\tx12824\tx13740\tx14655\ql\qnatural

\f3\b0\fs15 \cf0 \
typedef struct protocol_identifier \
\{\
    long    version;\
    NMType  type;\
    char    name[ kNMNameLength ];\
\} NMProtocol;\
\pard\sa240\ql\qnatural

\f1\fs20 \cf0 NMProtocol is used by the protocol indexing routines to return basic high-level information about a particular protocol. This information is usually used when preparing a user-interface for selecting a particular protocol. \
\pard\sa100\ql\qnatural

\f0\b\fs27 \cf0 NMHostID\
\pard\sa240\ql\qnatural

\f3\b0\fs15 \cf0 typedef NMUInt32 NMHostID; 
\f1\fs20 \
\pard\sa100\ql\qnatural

\f0\b\fs27 \cf0 NMEnumerationItem\
\pard\tx915\tx1831\tx2747\tx3662\tx4580\tx5495\tx6412\tx7327\tx8244\tx9160\tx10075\tx10990\tx11908\tx12824\tx13740\tx14655\ql\qnatural

\f3\b0\fs15 \cf0 \
typedef struct NMEnumerationItem\
\{\
    NMHostID  id;\
    char      *name;\
    NMUInt32  customEnumDataLen;\
    void      *customEnumData;\
\} NMEnumerationItem;\
\pard\sa240\ql\qnatural

\f1\fs20 \cf0 NMEnumerationItems are passed to your enumeration callback function during host enumeration. \
\pard\sa100\ql\qnatural

\f0\b\fs27 \cf0 NMEnumeractionCallbackPtr\
\pard\tx915\tx1831\tx2747\tx3662\tx4580\tx5495\tx6412\tx7327\tx8244\tx9160\tx10075\tx10990\tx11908\tx12824\tx13740\tx14655\ql\qnatural

\f3\b0\fs15 \cf0 \
typedef pascal void (*NMEnumerationCallbackPtr) ( void *inContext,\
                                                  NMEnumerationCommand inCommand, \
                                                  NMEnumerationItem *item \
                                                );\
\pard\sa100\ql\qnatural

\f0\b\fs27 \cf0 NMOpenFlags\
\pard\tx915\tx1831\tx2747\tx3662\tx4580\tx5495\tx6412\tx7327\tx8244\tx9160\tx10075\tx10990\tx11908\tx12824\tx13740\tx14655\ql\qnatural

\f3\b0\fs15 \cf0 \
typedef enum\
\{\
    kOpenNone = 0x00,\
    kOpenActive = 0x01\
\} NMOpenFlags;\
\pard\sa240\ql\qnatural

\f1\fs20 \cf0 kOpenActive indicates that you wish to open an active endpoint. This will also initiate things like dialing for a connection, etc. \
\pard\sa100\ql\qnatural

\f0\b\fs27 \cf0 NMModuleInfo\
\pard\tx915\tx1831\tx2747\tx3662\tx4580\tx5495\tx6412\tx7327\tx8244\tx9160\tx10075\tx10990\tx11908\tx12824\tx13740\tx14655\ql\qnatural

\f3\b0\fs15 \cf0 \
typedef struct NMModuleInfo\
\{\
    NMUInt32  size;\
    NMType    type;\
    char      name[ kNMNameLength ];\
    char      copyright[ kNMCopyrightLen ];\
    NMUInt32  maxPacketSize;\
    NMUInt32  maxEndpoints;\
    NMFlags   flags;\
\};\
\pard\sa240\ql\qnatural

\f1\fs20 \cf0 NMModuleInfo is used to return information about the OpenPlay module bound to a particular endpoint. \
\pard\sa100\ql\qnatural

\f0\b\fs27 \cf0 NMCallbackCode\
\pard\tx915\tx1831\tx2747\tx3662\tx4580\tx5495\tx6412\tx7327\tx8244\tx9160\tx10075\tx10990\tx11908\tx12824\tx13740\tx14655\ql\qnatural

\f3\b0\fs15 \cf0 \
typedef enum\
\{\
    kNMConnectRequest = 1,\
    kNMDatagramData,\
    kNMStreamData,\
    kNMFlowClear,\
    kNMAcceptComplete,\
    kNMHandoffComplete,\
    kNMEndpointDied,\
    kNMCloseComplete\
\} NMCallbackCode;\
\pard\sa100\ql\qnatural

\f0\b\fs27 \cf0 PConfigRef\
\pard\sa240\ql\qnatural

\f1\b0\fs20 \cf0 PConfigRef is an opaque type used to refer to a specific protocol configuration. \
\pard\sa100\ql\qnatural

\f0\b\fs27 \cf0 PEndpointCallbackFunction\
\pard\tx915\tx1831\tx2747\tx3662\tx4580\tx5495\tx6412\tx7327\tx8244\tx9160\tx10075\tx10990\tx11908\tx12824\tx13740\tx14655\ql\qnatural

\f3\b0\fs15 \cf0 \
typedef pascal void (*PEndpointCallbackFunction) ( PEndpointRef inEndpoint, \
                                                   void *inContext, \
                                                   *NMCallbackCode inCode, \
                                                   NMErr inError, \
                                                   void *inCookie\
                                                  );\
\pard\ql\qnatural

\f1\fs20 \cf0 \
\
\
\pard\sa100\qc

\f0\b\fs48 \cf0 API Reference\
\pard\ql\qnatural

\f1\b0\fs20 \cf0 \
\pard\sa100\qc

\f0\b\fs36 \cf0 Protocol Management\
\pard\ql\qnatural

\f1\b0\fs20 \cf0 \
\pard\sa100\ql\qnatural

\f0\b\fs27 \cf0 GetIndexedProtocol\
\pard\tx915\tx1831\tx2747\tx3662\tx4580\tx5495\tx6412\tx7327\tx8244\tx9160\tx10075\tx10990\tx11908\tx12824\tx13740\tx14655\ql\qnatural

\f3\b0\fs15 \cf0 \
NMErr\
GetIndexedProtocol( short      index, \
                    NMProtocol *protocol\
                  );\
\pard\sa240\ql\qnatural

\f1\fs20 \cf0 Given an index and a pointer to an allocated NMProtocol structure, fills in the structure with information about the specified protocol. \U8232 \uc0 \u8232 \U8232 \u8232 \
\pard\sa100\qc

\f0\b\fs36 \cf0 Configuration\
\pard\ql\qnatural

\f1\b0\fs20 \cf0 \
\pard\sa100\ql\qnatural

\f0\b\fs27 \cf0 ProtocolCreateConfig\
\pard\ql\qnatural

\f1\b0\fs20 \cf0 \
\pard\tx915\tx1831\tx2747\tx3662\tx4580\tx5495\tx6412\tx7327\tx8244\tx9160\tx10075\tx10990\tx11908\tx12824\tx13740\tx14655\ql\qnatural

\f3\fs15 \cf0 \
NMErr\
ProtocolCreateConfig( NMType      type, \
                      UInt32      game_id, \
                      const char  *game_name,\
                      const void  *enum_data, \
                      UInt32      enum_data_len, \
                      char        *configuration_string,\
                      PConfigRef  *outConfig\
                    );\
\pard\sa100\ql\qnatural

\f1\fs20 \cf0 Given a protocol "type", creates a new opaque configuration structure used for opening endpoints, enumerating hosts, and configuring the protocol. \
\pard\sa100\ql\qnatural

\f4\i \cf0 game_id
\f1\i0  is a unique identifier (usually the creator type) for the application using OpenPlay. \

\f4\i game_name
\f1\i0  is a C string, no longer than 32 bytes, to be used as an identifier on the network. \

\f4\i enum_data
\f1\i0  is custom data that the application can pass to OpenPlay to be included in an enumeration response. This parameter is optional, and is not used internally by OpenPlay. It should be set to nil if unused. \

\f4\i configuration_string
\f1\i0  is in the format of an OpenPlay configuration string, and specifies options about the configurator to create. This should be nil unless you want to override the default configuration. \

\f4\i outConfig
\f1\i0  is a pointer to a config ref that is created by this call. \
\pard\sa240\ql\qnatural
\cf0 \U8232 \uc0 \u8232 \
\pard\sa100\ql\qnatural

\f0\b\fs27 \cf0 ProtocolDisposeConfig\
\pard\tx915\tx1831\tx2747\tx3662\tx4580\tx5495\tx6412\tx7327\tx8244\tx9160\tx10075\tx10990\tx11908\tx12824\tx13740\tx14655\ql\qnatural

\f3\b0\fs15 \cf0 \
NMErr\
ProtocolDisposeConfig( PConfigRef config );\
\pard\sa240\ql\qnatural

\f1\fs20 \cf0 Given a previously created configurator, disposes of the configurator and all its associated memory. \U8232 \uc0 \u8232 \
\pard\sa100\ql\qnatural

\f0\b\fs27 \cf0 ProtocolGetConfigString\
\pard\tx915\tx1831\tx2747\tx3662\tx4580\tx5495\tx6412\tx7327\tx8244\tx9160\tx10075\tx10990\tx11908\tx12824\tx13740\tx14655\ql\qnatural

\f3\b0\fs15 \cf0 \
NMErr\
ProtocolGetConfigString( PConfigRef  config, \
                         char        *config_string, \
                         short       max_length\
                       );\
\pard\sa240\ql\qnatural

\f1\fs20 \cf0 Given a configurator and a pointer to an allocated string, writes out a string version of the configuration information. This is used for storing information about a connection. \U8232 \uc0 \u8232 \
\pard\sa100\ql\qnatural

\f0\b\fs27 \cf0 ProtocolGetConfigStringLen\
\pard\tx915\tx1831\tx2747\tx3662\tx4580\tx5495\tx6412\tx7327\tx8244\tx9160\tx10075\tx10990\tx11908\tx12824\tx13740\tx14655\ql\qnatural

\f3\b0\fs15 \cf0 \
NMErr\
ProtocolGetConfigStringLen( PConfigRef  config, \
                            short      *length\
                          );\
\pard\sa240\ql\qnatural

\f1\fs20 \cf0 Given a configurator, returns the required space (in bytes) to store the configurator into a string. \U8232 \uc0 \u8232 \
\pard\sa100\ql\qnatural

\f0\b\fs27 \cf0 ProtocolBindEnumerationToConfig\
\pard\tx915\tx1831\tx2747\tx3662\tx4580\tx5495\tx6412\tx7327\tx8244\tx9160\tx10075\tx10990\tx11908\tx12824\tx13740\tx14655\ql\qnatural

\f3\b0\fs15 \cf0 \
NMErr\
ProtocolBindEnumerationToConfig( PConfigRef config, \
                                 NMHostID   inID\
                               );\
\pard\sa240\ql\qnatural

\f1\fs20 \cf0 Given a host id (from enumeration), binds that enumeration item to a configurator. This function should only be called during enumeration (after call to ProtocolStartEnumeration and before call to ProtocolEndEnumeration). \U8232 \uc0 \u8232 \U8232 \u8232 \
\pard\sa100\qc

\f0\b\fs36 \cf0 Enumeration Functions\
\pard\ql\qnatural

\f1\b0\fs20 \cf0 \
\pard\sa100\ql\qnatural

\f0\b\fs27 \cf0 ProtocolStartEnumeration\
\pard\tx915\tx1831\tx2747\tx3662\tx4580\tx5495\tx6412\tx7327\tx8244\tx9160\tx10075\tx10990\tx11908\tx12824\tx13740\tx14655\ql\qnatural

\f3\b0\fs15 \cf0 \
NMErr \
ProtocolStartEnumeration( PConfigRef               config,\
                          NMEnumerationCallbackPtr inCallback, \
                          void                     *inContext, \
                          NMBoolean                inActive\
                        );\
\pard\sa240\ql\qnatural

\f1\fs20 \cf0 Given a configurator, enumerates the available hosts (to which a connection can be made). Enumeration can be active, meaning that the protocol module sends out packets on the network to discover hosts, or passive, meaning that the module only reports potential hosts it knows about from storage (preferences). The 
\f4\i inCallback
\f1\i0  and 
\f4\i inContext
\f1\i0  parameters are used to make callbacks to the application when new hosts are found or old ones are no longer available. \U8232 \uc0 \u8232 \
\pard\sa100\ql\qnatural

\f0\b\fs27 \cf0 ProtocolIdleEnumeration\
\pard\tx915\tx1831\tx2747\tx3662\tx4580\tx5495\tx6412\tx7327\tx8244\tx9160\tx10075\tx10990\tx11908\tx12824\tx13740\tx14655\ql\qnatural

\f3\b0\fs15 \cf0 \
NMErr\
ProtocolIdleEnumeration( PConfigRef config );\
\pard\sa240\ql\qnatural

\f1\fs20 \cf0 The configurator must be one that has already been passed to a successful call to ProtocolStartEnumeration. This function gives the protocol module time to update its lists of available hosts. It must be called repeatedly during enumeration. \U8232 \uc0 \u8232 \
\pard\sa100\ql\qnatural

\f0\b\fs27 \cf0 ProtocolEndEnumeration\
\pard\tx915\tx1831\tx2747\tx3662\tx4580\tx5495\tx6412\tx7327\tx8244\tx9160\tx10075\tx10990\tx11908\tx12824\tx13740\tx14655\ql\qnatural

\f3\b0\fs15 \cf0 \
NMErr\
ProtocolEndEnumeration( PConfigRef config );\
\pard\sa240\ql\qnatural

\f1\fs20 \cf0 The configurator must be one that has already been passed to a successful call to ProtocolStartEnumeration. This function ends the enumeration. No further enumeration callbacks will be made once this function completes. Host IDs returned by enumeration callbacks are no longer valid after this function completes.\U8232 \uc0 \u8232 \U8232 \u8232 \U8232 \u8232 \
\pard\sa100\qc

\f0\b\fs36 \cf0 Dialog Functions\
\pard\ql\qnatural

\f1\b0\fs20 \cf0 \
\pard\sa100\ql\qnatural

\f0\b\fs27 \cf0 ProtocolSetupDialog\
\pard\tx915\tx1831\tx2747\tx3662\tx4580\tx5495\tx6412\tx7327\tx8244\tx9160\tx10075\tx10990\tx11908\tx12824\tx13740\tx14655\ql\qnatural

\f3\b0\fs15 \cf0 \
NMErr\
ProtocolSetupDialog( DIALOGPTR  dialog, \
                     short      frame, \
                     short      inBaseItem,\
                     PConfigRef config\
                   );\
\pard\sa240\ql\qnatural

\f1\fs20 \cf0 The application passes a dialog pointer, the id of the frame item, and the count of the current number of items in the dialog to OpenPlay. Also passed is a valid configurator. OpenPlay forwards this information on to the appropriate net module to set up its configuration dialog items. \U8232 \uc0 \u8232 \
\pard\sa100\ql\qnatural

\f0\b\fs27 \cf0 ProtocolHandleEvent\
\pard\tx915\tx1831\tx2747\tx3662\tx4580\tx5495\tx6412\tx7327\tx8244\tx9160\tx10075\tx10990\tx11908\tx12824\tx13740\tx14655\ql\qnatural

\f3\b0\fs15 \cf0 \
NMBoolean\
ProtocolHandleEvent( DIALOGPTR  dialog, \
                     EVENT      *event, \
                     PConfigRef config\
                   );\
\pard\sa240\ql\qnatural

\f1\fs20 \cf0 This function passes a dialog event to the appropriate net module. \U8232 \uc0 \u8232 \
\pard\sa100\ql\qnatural

\f0\b\fs27 \cf0 ProtocolHandleItemHit\
\pard\tx915\tx1831\tx2747\tx3662\tx4580\tx5495\tx6412\tx7327\tx8244\tx9160\tx10075\tx10990\tx11908\tx12824\tx13740\tx14655\ql\qnatural

\f3\b0\fs15 \cf0 \
NMErr\
ProtocolHandleItemHit( DIALOGPTR  dialog, \
                       short      inItemHit, \
                       PConfigRef config\
                     );\
\pard\sa240\ql\qnatural

\f1\fs20 \cf0 Notifies the underlying net module when one of its dialog items has been hit. \U8232 \uc0 \u8232 \
\pard\sa100\ql\qnatural

\f0\b\fs27 \cf0 ProtocolDialogTeardown\
\pard\tx915\tx1831\tx2747\tx3662\tx4580\tx5495\tx6412\tx7327\tx8244\tx9160\tx10075\tx10990\tx11908\tx12824\tx13740\tx14655\ql\qnatural

\f3\b0\fs15 \cf0 \
NMBoolean\
ProtocolDialogTeardown( DIALOGPTR  dialog, \
                        NMBoolean  update_config,\
                        PConfigRef config\
                      );\
\pard\sa240\ql\qnatural

\f1\fs20 \cf0 Have the underlying protocol module tear down its configuration dialog. If update_config is true, the configurator is updated with information from the user's interaction with the dialog. Otherwise the configurator remains unmodified. \U8232 \uc0 \u8232 \
\pard\sa100\ql\qnatural

\f0\b\fs27 \cf0 ProtocolGetRequiredDialogFrame\
\pard\tx915\tx1831\tx2747\tx3662\tx4580\tx5495\tx6412\tx7327\tx8244\tx9160\tx10075\tx10990\tx11908\tx12824\tx13740\tx14655\ql\qnatural

\f3\b0\fs15 \cf0 \
void\
ProtocolGetRequiredDialogFrame( RECT       *r, \
                                PConfigRef config\
                              );\
\pard\sa240\ql\qnatural

\f1\fs20 \cf0 Returns the space required by the specified protocol module to present user configuration HI. \U8232 \uc0 \u8232 \U8232 \u8232 \
\pard\sa100\qc

\f0\b\fs36 \cf0 Endpoint Opening/Closing Functions\
\pard\ql\qnatural

\f1\b0\fs20 \cf0 \
\pard\sa100\ql\qnatural

\f0\b\fs27 \cf0 ProtocolOpenEndpoint\
\pard\tx915\tx1831\tx2747\tx3662\tx4580\tx5495\tx6412\tx7327\tx8244\tx9160\tx10075\tx10990\tx11908\tx12824\tx13740\tx14655\ql\qnatural

\f3\b0\fs15 \cf0 \
NMErr\
ProtocolOpenEndpoint( PConfigRef   inConfig, \
                      PEndpointCallbackFunction inCallback, \
                      void         *inContext, \
                      PEndpointRef *outEndpoint, \
                      NMOpenFlags  flags\
                    );\
\pard\sa100\ql\qnatural

\f1\fs20 \cf0 Synchronously opens an endpoint. \
\pard\sa100\ql\qnatural

\f4\i \cf0 inConfig
\f1\i0  tells OpenPlay what kind of endpoint to open, and specifies any special information, such as the address of a host to connect to, or the port to listen on. \

\f4\i inCallback
\f1\i0  and 
\f4\i inContext
\f1\i0  are used by OpenPlay to make callbacks to the application when asynchronous events, such as the arrival of new data, occur. \

\f4\i outEndpoint
\f1\i0  is filled in with an endpoint reference when the call completes successfully. \

\f4\i flags
\f1\i0  determines whether the endpoint will be opened as active or passive (kOpenActive or kOpenNone). \
\pard\sa240\ql\qnatural
\cf0 \U8232 \uc0 \u8232 \
\pard\sa100\ql\qnatural

\f0\b\fs27 \cf0 ProtocolCloseEndpoint\
\pard\tx915\tx1831\tx2747\tx3662\tx4580\tx5495\tx6412\tx7327\tx8244\tx9160\tx10075\tx10990\tx11908\tx12824\tx13740\tx14655\ql\qnatural

\f3\b0\fs15 \cf0 \
NMErr\
ProtocolCloseEndpoint( PEndpointRef endpoint, \
                       NMBoolean inOrderly\
                     );\
\pard\sa100\ql\qnatural

\f1\fs20 \cf0 Asynchronously closes a previously opened endpoint. \
\pard\sa100\ql\qnatural

\f4\i \cf0 inOrderly
\f1\i0  specifies whether disconnections should be done in an "orderly" fashion. Not all protocol modules will support orderly disconnections. \
\pard\sa240\ql\qnatural
\cf0 \U8232 \uc0 \u8232 \U8232 \u8232 \
\pard\sa100\qc

\f0\b\fs36 \cf0 Connection Options Functions\
\pard\ql\qnatural

\f1\b0\fs20 \cf0 \
\pard\sa100\ql\qnatural

\f0\b\fs27 \cf0 ProtocolSetTimeout\
\pard\tx915\tx1831\tx2747\tx3662\tx4580\tx5495\tx6412\tx7327\tx8244\tx9160\tx10075\tx10990\tx11908\tx12824\tx13740\tx14655\ql\qnatural

\f3\b0\fs15 \cf0 \
NMErr\U8232 \uc0 \u8232 \
ProtocolSetTimeout( PEndpointRef endpoint, \
                    long timeout\
                  );\
\pard\sa240\ql\qnatural

\f1\fs20 \cf0 Sets the default timeout for asynchronous operations. \U8232 \uc0 \u8232 \
\pard\sa100\ql\qnatural

\f0\b\fs27 \cf0 ProtocolIsAlive\
\pard\tx915\tx1831\tx2747\tx3662\tx4580\tx5495\tx6412\tx7327\tx8244\tx9160\tx10075\tx10990\tx11908\tx12824\tx13740\tx14655\ql\qnatural

\f3\b0\fs15 \cf0 \
NMBoolean\
ProtocolIsAlive( PEndpointRef endpoint );\
\pard\sa240\ql\qnatural

\f1\fs20 \cf0 Reports whether the specified endpoint is "alive" (connected to something on the other end). Returns a tri-state\'d0 true, false, or unknown. \U8232 \uc0 \u8232 \
\pard\sa100\ql\qnatural

\f0\b\fs27 \cf0 ProtocolIdle\
\pard\tx915\tx1831\tx2747\tx3662\tx4580\tx5495\tx6412\tx7327\tx8244\tx9160\tx10075\tx10990\tx11908\tx12824\tx13740\tx14655\ql\qnatural

\f3\b0\fs15 \cf0 \
NMErr\
ProtocolIdle( PEndpointRef endpoint );\
\pard\sa240\ql\qnatural

\f1\fs20 \cf0 If a protocol module specifies that it requires idle time (in the ProtocolGetEndpointInfo function), you must give the module processing time by calling this function on all endpoints created by the module. \U8232 \uc0 \u8232 \
\pard\sa100\ql\qnatural

\f0\b\fs27 \cf0 ProtocolFunctionPassThrough\
\pard\tx915\tx1831\tx2747\tx3662\tx4580\tx5495\tx6412\tx7327\tx8244\tx9160\tx10075\tx10990\tx11908\tx12824\tx13740\tx14655\ql\qnatural

\f3\b0\fs15 \cf0 \
NMErr\
ProtocolFunctionPassThrough( PEndpointRef  endpoint, \
                             unsigned long inSelector,\
                             void          *inParamBlock\
                           );\
\pard\sa240\ql\qnatural

\f1\fs20 \cf0 This function is optionally implemented, and provides a "back door" into functions available by the underlying net module. \U8232 \uc0 \u8232 \U8232 \u8232 \
\pard\sa100\qc

\f0\b\fs36 \cf0 Connection Functions\
\pard\ql\qnatural

\f1\b0\fs20 \cf0 \
\pard\sa100\ql\qnatural

\f0\b\fs27 \cf0 ProtocolAcceptConnection\
\pard\tx915\tx1831\tx2747\tx3662\tx4580\tx5495\tx6412\tx7327\tx8244\tx9160\tx10075\tx10990\tx11908\tx12824\tx13740\tx14655\ql\qnatural

\f3\b0\fs15 \cf0 \
NMErr\
ProtocolAcceptConnection( PEndpointRef               endpoint, \
                          void                       *inCookie,\
                          PEndpointCallbackFunction inNewCallback, \
                          void                      *inNewContext\
                        );\
\pard\sa100\ql\qnatural

\f1\fs20 \cf0 Asynchronously accepts a connection on a specified endpoint. \
\pard\sa100\ql\qnatural

\f4\i \cf0 inCookie
\f1\i0  is the cookie that was passed to the application along with a connection request callback. \
Pass an 
\f4\i inNewCallback
\f1\i0  and 
\f4\i inNewContext
\f1\i0  for the new endpoint that will be created when the accept_complete event callback is made. \
\pard\sa240\ql\qnatural
\cf0 \U8232 \uc0 \u8232 \
\pard\sa100\ql\qnatural

\f0\b\fs27 \cf0 ProtocolRejectConnection\
\pard\tx915\tx1831\tx2747\tx3662\tx4580\tx5495\tx6412\tx7327\tx8244\tx9160\tx10075\tx10990\tx11908\tx12824\tx13740\tx14655\ql\qnatural

\f3\b0\fs15 \cf0 \
NMErr\
ProtocolRejectConnection( PEndpointRef endpoint, \
                          void *inCookie\
                        );\
\pard\sa100\ql\qnatural

\f1\fs20 \cf0 Reject a connection request. \
\pard\sa100\ql\qnatural

\f4\i \cf0 inCookie
\f1\i0  is the cookie that was passed along with the connection request callback. \
\pard\sa240\ql\qnatural
\cf0 \U8232 \uc0 \u8232 \
\pard\sa100\qc

\f0\b\fs36 \cf0 Datagram Sending/Receiving Functions\
\pard\ql\qnatural

\f1\b0\fs20 \cf0 \
\pard\sa100\ql\qnatural

\f0\b\fs27 \cf0 ProtocolSendPacket\
\pard\tx915\tx1831\tx2747\tx3662\tx4580\tx5495\tx6412\tx7327\tx8244\tx9160\tx10075\tx10990\tx11908\tx12824\tx13740\tx14655\ql\qnatural

\f3\b0\fs15 \cf0 \
NMErr\
ProtocolSendPacket( PEndpointRef endpoint, \
                    void         *inData, \
                    long         inLength,\
                    NMFlags      inFlags\
                  );\
\pard\sa240\ql\qnatural

\f1\fs20 \cf0 Sends a packet (defined as data whose length is less than the net module's maximum packet size) down the specified endpoint. This data is not guaranteed to arrive at the other end. inFlags is not currently used. \U8232 \uc0 \u8232 \
\pard\sa100\ql\qnatural

\f0\b\fs27 \cf0 ProtocolReceivePacket\
\pard\tx915\tx1831\tx2747\tx3662\tx4580\tx5495\tx6412\tx7327\tx8244\tx9160\tx10075\tx10990\tx11908\tx12824\tx13740\tx14655\ql\qnatural

\f3\b0\fs15 \cf0 \
NMErr\
ProtocolReceivePacket( PEndpointRef  endpoint, \
                       void          *outData, \
                       unsigned long *ioSize, \
                       NMFlags       *outFlags\
                     );\
\pard\sa240\ql\qnatural

\f1\fs20 \cf0 Receives a packet on the specified endpoint in response to a datagram arrived callback message. This function should be called repeatedly until a kNMNoDataErr is returned. Specify the size of your buffer in the ioSize parameter. The amount of data actually read will be returned in this parameter. \U8232 \uc0 \u8232 \U8232 \u8232 \
\pard\sa100\qc

\f0\b\fs36 \cf0 Data Stream Sending/Receiving Functions\
\pard\ql\qnatural

\f1\b0\fs20 \cf0 \
\pard\sa100\ql\qnatural

\f0\b\fs27 \cf0 ProtocolSend\
\pard\tx915\tx1831\tx2747\tx3662\tx4580\tx5495\tx6412\tx7327\tx8244\tx9160\tx10075\tx10990\tx11908\tx12824\tx13740\tx14655\ql\qnatural

\f3\b0\fs15 \cf0 \
long\
ProtocolSend( PEndpointRef  endpoint, \
              void          *inData, \
              unsigned long inSize,\
              NMFlags       inFlags\
            );\
\pard\sa240\ql\qnatural

\f1\fs20 \cf0 Sends an arbitrary amount of data down the stream (reliable) endpoint. The return value indicates the actual number of bytes sent. \U8232 \uc0 \u8232 \
\pard\sa100\ql\qnatural

\f0\b\fs27 \cf0 ProtocolReceive\
\pard\tx915\tx1831\tx2747\tx3662\tx4580\tx5495\tx6412\tx7327\tx8244\tx9160\tx10075\tx10990\tx11908\tx12824\tx13740\tx14655\ql\qnatural

\f3\b0\fs15 \cf0 \
NMErr\
ProtocolReceive( PEndpointRef  endpoint, \
                 void          *outData, \
                 unsigned long *ioSize, \
                 NMFlags       *outFlags\
               );\
\pard\sa240\ql\qnatural

\f1\fs20 \cf0 Receives an arbitrary amount of data down the stream (reliable) endpoint. \U8232 \uc0 \u8232 \U8232 \u8232 \
\pard\sa100\qc

\f0\b\fs36 \cf0 Information Functions\
\pard\ql\qnatural

\f1\b0\fs20 \cf0 \
\pard\sa100\ql\qnatural

\f0\b\fs27 \cf0 ProtocolGetEndpointInfo\
\pard\tx915\tx1831\tx2747\tx3662\tx4580\tx5495\tx6412\tx7327\tx8244\tx9160\tx10075\tx10990\tx11908\tx12824\tx13740\tx14655\ql\qnatural

\f3\b0\fs15 \cf0 \
NMErr\
ProtocolGetEndpointInfo( PEndpointRef endpoint, \
                         NMModuleInfo *info);\
\pard\sa240\ql\qnatural

\f1\fs20 \cf0 Gets information about the net module associated with the given endpoint. \U8232 \uc0 \u8232 \
\pard\ql\qnatural
\cf0 \
}