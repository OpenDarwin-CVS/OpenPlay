/* * OpenPlay/NetSprocket Release Notes * * Modified: $Date$ * Revision: $Id$ */CONTENTS---------- General- About NetSprocketMode- Documentation Error- A Note On Game Names- Getting The Most Out Of NetSprocketGeneral-------The original NSp 1.7 PDF file has been included as a reference. Since the API has largely remained intact, the document is generally valid despite being a bit dated. An update is being worked on, please feel free to submit changes/error reports (see "Submitting NetSprocket Modifications" in README.txt).The NetSprocket and OpenPlay libraries have now been merged into one (OpenPlay). The only change this will require in projects is linking against OpenPlay's stub library instead of NetSprocket's. However, if you wish to create standalone NetSprocket and OpenPlay libraries, do the following:-Duplicate OpenPlayLib.mcp, rename it NetSprocketLib.mcp, change its target names and/or Fragment Name to NetSprocketLib, NetSprocketCarbonLib, or NetSprocket.dll.-Duplicate OpenPlay's .exp files (OpenPlayMac.exp, OpenPlayWin.exp), rename them NetSprocketMac.exp/NetSprocketWin.exp, remove openplay functions, and include them in the project in place of the originals-Remove all OpenPlay source files from the project and add OpenPlay's lib/stub libs in their place.To create the non-netsprocket OpenPlayLib, simply remove netsprocket functions from OpenPlayMac.exp and OpenPlayWin.exp, and remove all NetSprocket source files from the project.About NetSprocketMode____________________NetSprocketMode is a mode of operation for OpenPlay's current NetModules which slightly alters their behavior. It was created for NetSprocket's use of OpenPlay in order to maintain compatability with older versions of NetSprocket, but It may be of interest to other developers, particularly those using TCPIP. When using NetSprocketMode, incoming datagrams do not specify which endpoint they are from. Generally their endpoint value will be that of your original passive endpoint. In standard mode with the TCPIP module, a client connects to a specific IP address on a specific port. The server, upon accepting the connection, opens a new, seperate endpoint on any available port, and sends this new address to the client for it to open the datagram connection. In netSprocketMode, no seperate endpoint is opened - all datagram traffic goes to the original port (thus the loss of datagram identity) One benefit to this is that it will be compatable with future TCPIP flavors, since it requires no address to be sent from one machine to another. Another benefit is that machines behind a firewall with a single "blessed" port can host a game without their datagram connection being blocked.To enable NetSprocketMode, include the following in your configuration string:	netSprocket=trueIf you use NetSprocketMode, your code will still work with future NetModules that might not support it, because you'll simply be ignoring the endpoint values attached to datagrams.Documentation Error (From original NSp 1.7 release)___________________An error has been found in the documentation for NetSprocket. The original "Apple Game Sprockets Guide 1.0" documentation said that you should call NSpReleaseAddressReference() to free the memory used by address references. You must make sure that you only use this on address references that were allocated by NetSprocket (such as NSpDoModalJoinDialog(). This is especially critical when using address references generated by the NSpConvertOTAddrToAddressReference() function.If you allocate your own OTAddress structures and then convert them to NSpAddressReferences you should not use NSpReleaseAddressReference() to free this memory. Release your OTAddress allocations as you normally would.NOTE: As of NetSprocket 2.0, the previous advice is no longer true. Specifically, if you convert an OTAddress to a NSpAddressReference using SpConvertOTAddrToAddressReference(), then you *must* call SpReleaseAddressReference(), because the conversion is no longer done in-place, and NetSprocket needs to free the memory that it allocated for the out-of-place operation.A Note On Game Names____________________When you are hosting a game with NetSprocket you provide a name for the game in the host dialog. When playing over AppleTalk this name is used with NBP (Name Binding Protocol) to advertise your game on the LAN. There are a few special characters that should not be used in game names because they have special meaning in AppleTalk. These characters are: * - asterisk ‰ - option x / - forward slash @ - at sign : - colonGetting the Most Out of NetSprocket___________________________________There is a new version of NetSprocketTest that should provide a better example of how to effectively use NetSprocket. The most important thing to note is how NetSprocket messages are handled both synchronously and asynchronously. This method prevents problems where user actions, such as a mouse-down, could prevent the main event loop from calling NSpMessage_Get, and thereby cause a buffer overflow problem.The number one problem we've seen with people using NetSprocket is apps running out of memory. The reason this happens is that NetSprocket presents a message API to the application. If you have, say, a 50K message, NetSprocket doesn't hand that message to the client application until all 50K are received. This model makes NetSprocket much more susceptible to low memory problems than other, data-oriented, networking APIs. There are three things you cando to minimize this kind of problem.	1. Use small messages ( < 1K) as often as is practical	2. 	Give NetSprocket as much memory as you can spare	3. Use the async message hander	NetSprocket will still function if you don't do these things, but end user conditions will be much more likely to cause your app problems.You should always check return values from NetSprocket functions. Failure to do so is reckless, and will only cause you and your customers headaches.If the user unchecks the "play on this machine" button, the hosting machine must not send any messages to other players. The host machine only acts to  route messages between the various players -- while it can act on messages that are copied to it, it cannot directly message other players. If the host  needs to send messages to other players, the host should be implemented as a special kind of player. If you need to disable the "play on this machine" button, create a custom host dialog box that does not provide that option.When connecting to a game for the first time, a client application is not permitted to send messages to other players until it receives the join approved message. The application should spin waiting for a join approved, join denied, or game terminated message. If you do receive a join denied or game terminated message, you are not permitted to send messages to any other players in the game. In actuality, the connection to the host has already been terminated. Future versions of NetSprocket may return control to the client app before the connection is completely established, so assuming you can send messages immediately after the NSpGame_Join call has returned is an error.To get the optimal performance out of NetSprocket, design your game to send "Normal" messages that contain less than 550 bytes of data. This allows NetSprocket to use datagram-level delivery for both TCP/IP and AppleTalk. Using "Registered" messages can cause a 2-50% network performance degradation, depending on a number of factors, including network bandwidth, utilization, message size, and send frequency.All messages, except ones sent from a player to himself, are sent through the host. Therefore, the host is one "hop" from any other player, and two non-host players are always two "hops" apart.Sending a message to a group is not as efficient as sending to everyone in the game, or to a single player. It is usually more efficient than sending to each individual in the group separately.You CAN NOT send messages at VBL (or any other interrupt) time with NetSprocket. You should schedule a deferred system task, or just wait until system task time before sending. You CAN however, call NSpMessage_Get at interrupt time. We generally recommend against all interrupt-time calls to the Game Sprockets.The number of players in a NetSprocket game is limited only by memory (and networking resources, such as available ports). If you expect to handle lots of players (14+), you need to make sure you give NetSprocket sufficient memory and queue elements when you initialize it. If you get send failed or memory error message from NetSprocket, try giving it more memory.If you have a situation where your game has players whose network throughput is greatly disparate, you need to make sure you don't choke the slow person. For example, if you have 4 players on AppleTalk over Ethernet, and you have a fifth player join the game over a 28.8k PPP connection, and your fast machines are sending messages 30 times a second each, you're going to quickly gag the newcomer with too much data, and the host will simply not be able to deliver messages as quickly as you generate them. The newcomer will be disconnected after approximately 20 messages have been queued up, waiting for flow control to lift before delivering them. You can avoid this type of problem by throttling down your game's send rate to allow the newcomer to participate. You can also avoid it by sending "Junk" messages instead of Normal.