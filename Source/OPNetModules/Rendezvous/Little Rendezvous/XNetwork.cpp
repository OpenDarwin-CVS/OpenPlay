/*	11/14/02 * *	Rocco Bowling *	Feline Entertainment *	http://homepage.mac.com/felinegames *	http://homepage.mac.com/felinegames/games/thebelt/index.html *	felinegames@mac.com *	 *	This source code is part of The Belt, my entry in the 2002 uDevGame Mac Game Programming *	contest (refer to www.idevgames.com for more details).  My main goal for The Belt in  *	relation to the purpose of the contest was to create a game which was cross platform *	Mac and Windows from the same CodeWarrior project, without relying on third-party *	cross platform libraries.  Hence, in the bowels of this code you will find functions *	which handle the Mac case, as well as the functions which handles the Windows case. *	Most of the cross platform issues are encapsulated in the engine code, which allows *	you to modify The Belt itself in an easy, platform independent manner.  The Belt *	is also an example of good program design, with modular pieces of code, as well *	as centralized object and application managers. * *	For the record, this program is provided on an "as-is" basis for educational purposes *	only.  The source code is subject to the uDevGame Source Code License, so please refer *	to that if you have any questions. * *	If you have any questions specific to the code, feel free to send me an email. *//* XNetwork.cc * * Simple wrapper around OpenTransport on the Mac Carbon side and WinSock on the Windows side. * Has everything you need to get up and running with UDP packets across IP. * */#pragma mark *** Includes ***#include "XNetwork.h"#include <stdlib.h>#ifdef TARGET_WINDOWS#include <PROCESS.H>#endif#pragma mark *** Definitions ***#define kMaxMessage 4096typedef struct{	unsigned short msg_size;	char msg[kMaxMessage];}msgRecord;enum {    kOTActive = 0x01,    kOTEndpointCreated = 0x02,    kOTEndpointBound = 0x04,    kOTLastFlag = 0x8000};#pragma mark *** Globals ***static int windowsInited = 0;static msgRecord globalMsg;static int OTpInited = 0;// 11/24/02 Added for integration into OpenPlayextern OTClientContextPtr	gOTClientContext;#pragma mark *** Prototypes ***#pragma mark -#pragma mark *** Code ***#pragma mark *** MacOS Helper Functions ***#ifdef TARGET_MAC_CARBONstatic OTResult SetFourByteOption(EndpointRef ep, OTXTILevel level, OTXTIName name, UInt32 value){	OTResult err;	TOption option;	TOptMgmt request;	TOptMgmt result;		/* Set up the option buffer to specify the option and value to	set. */	option.len = kOTFourByteOptionSize;	option.level = level;	option.name = name;	option.status = 0;	option.value[0] = value;		/* Set up request parameter for OTOptionManagement */	request.opt.buf = (UInt8 *) &option;	request.opt.len = sizeof(option);	request.flags = T_NEGOTIATE;		/* Set up reply parameter for OTOptionManagement. */	result.opt.buf = (UInt8 *) &option;	result.opt.maxlen = sizeof(option);		OTSetSynchronous(ep);		err = OTOptionManagement(ep, &request, &result);		OTSetAsynchronous(ep);	if(err == noErr) {		if(option.status != T_SUCCESS)		err = option.status;	}		return err;}static void setIPMulticastOption(EndpointRef ep){	TOptMgmt 			optReq;	UInt8	 			optBuffer[ kOTOptionHeaderSize + sizeof(TIPAddMulticast) ];	TOption*	 		opt = (TOption*)optBuffer;	TIPAddMulticast*	addopt = (TIPAddMulticast*)opt->value;	OSStatus 			err;		char			gMulticastAddrStr[] = "224.0.0.251";	InetPort		gMulticastPort = 53535;	InetHost		gMulticastHost;	InetAddress		gMulticastAddr;		OTInetStringToHost(gMulticastAddrStr, &gMulticastHost);	OTInitInetAddress(&gMulticastAddr, gMulticastPort, gMulticastHost);		optReq.flags 		= T_NEGOTIATE;	optReq.opt.len 		= sizeof(optBuffer);	optReq.opt.maxlen 	= sizeof(optBuffer);	optReq.opt.buf 		= (UInt8*) optBuffer;		opt->level = INET_IP;	opt->name = IP_ADD_MEMBERSHIP;	opt->len = sizeof(optBuffer);		addopt->multicastGroupAddress = gMulticastHost;	addopt->interfaceAddress = kOTAnyInetAddress;		err = OTOptionManagement(ep, &optReq, &optReq);	if ( err < kOTNoError ){		fprintf(stderr, "ERROR: OTOptionManagement() (add membership) failed with %d\n", err);	}}static pascal void EventHandler(void * contextPtr, OTEventCode event, OTResult result, void * cookie){    net_communication * comm = (net_communication *)contextPtr;    void (*callback)(net_communication * comm, char * buffer, unsigned int size, net_address * source) =     		(void (*)(net_communication * comm, char * buffer, unsigned int size, net_address * source))comm->dataFunc;    char buffer[kMaxMessage] = {0};    unsigned int size;    net_address source;        #pragma unused (result, cookie)                switch (event)    {                    case T_DATA:		/* Standard data is available			*/            if(callback){		    	while((size = recvNetworkPacket(comm, buffer, kMaxMessage, &source)) > 0){    				buffer[size] = 0;			        (*callback)(comm, buffer, size, &source);			    }            }            break;        case T_UNBINDCOMPLETE:	                                                                                                                                                         	    printf("T_UNBINDCOMPLETE event occurred\n");            comm->status &= (-1 ^ kOTEndpointBound);            break;        default:            printf("EventHandler got unexpected event %ld\n", event);            break;    }    return;}#pragma mark -static pascal void TCPServerEventHandler(void * contextPtr, OTEventCode event, OTResult result, void * cookie){    net_communication * comm = (net_communication *)contextPtr;    void (*callback)(net_communication * comm, char * buffer, unsigned int size, net_address * source) =     		(void (*)(net_communication * comm, char * buffer, unsigned int size, net_address * source))comm->dataFunc;    char buffer[kMaxMessage] = {0};    net_address source = {0};    msgRecord localMsg = {0};        #pragma unused (result, cookie)        switch (event)    {        case T_LISTEN:			struct InetAddress rcvsin;			TCall call;			#if DEBUG			fprintf(stderr, "T_LISTEN\n");#endif			// Incoming connection... accept it by default...			memset(&call, 0, sizeof(TCall));						call.addr.maxlen = sizeof(struct InetAddress);			call.addr.len = sizeof(struct InetAddress);			call.addr.buf = (unsigned char *) &rcvsin;			call.opt.maxlen = 0;			call.opt.buf = 0;			call.udata.maxlen = 0;						OTListen(comm->endpoint, &call);						if(comm->tcp_connected){				OTSndDisconnect(comm->endpoint, &call);			}else{				comm->client_call = call;				OTAccept(comm->endpoint, comm->client_endpoint, &comm->client_call);	        }        	comm->tcp_connected = 1;	        break;	        		case T_ACCEPTCOMPLETE:			// Call the callback with the buffer as zero... implies connection received...#if DEBUG			fprintf(stderr, "T_ACCEPTCOMPLETE\n");#endif			break;							case T_ORDREL:#if DEBUG			fprintf(stderr, "T_ORDREL\n");#endif			if(comm->tcp_connected){				OTRcvOrderlyDisconnect(comm->client_endpoint);				OTSndOrderlyDisconnect(comm->client_endpoint);			}else{				OTRcvOrderlyDisconnect(comm->client_endpoint);			}						comm->tcp_connected = 0;			break;					case T_DISCONNECT:#if DEBUG			fprintf(stderr, "T_DISCONNECT\n");#endif			OTRcvDisconnect(comm->client_endpoint, nil);			comm->tcp_connected = 0;			break;				case T_DISCONNECTCOMPLETE:#if DEBUG			fprintf(stderr, "T_DISCONNECTCOMPLETE\n");#endif			comm->tcp_connected = 0;			break;				        case T_DATA:		/* Standard data is available			*/            if(callback){            	OSStatus err;            	            	while(1){            		if((err = OTRcv(comm->client_endpoint, &localMsg.msg_size, sizeof(unsigned short), 0)) == sizeof(unsigned short)){            			err = OTRcv(comm->client_endpoint, &localMsg.msg, localMsg.msg_size, 0);				        (*callback)(comm, (char *)&localMsg.msg, localMsg.msg_size, &source);            		}            		if(err < kOTNoDataErr){            			fprintf(stderr, "Error %d with OTRcv()\n", err);            			break;            		}            		if(err == kOTNoDataErr){            			break;            		}            	}            }            break;				case T_PASSCON:#if DEBUG			fprintf(stderr, "T_PASSCON\n");#endif			if(callback){	        	(*callback)(comm, 0, 0, &source);	        }			break;			        default:            printf("TCPServerEventHandler got unexpected event %ld\n", event);            break;    }    return;}static pascal void TCPClientEventHandler(void * contextPtr, OTEventCode event, OTResult result, void * cookie){    net_communication * comm = (net_communication *)contextPtr;    void (*callback)(net_communication * comm, char * buffer, unsigned int size, net_address * source) =     		(void (*)(net_communication * comm, char * buffer, unsigned int size, net_address * source))comm->dataFunc;    char buffer[kMaxMessage] = {0};    net_address source = {0};    msgRecord localMsg;        #pragma unused (result, cookie)                    switch (event)    {        case T_CONNECT:#if DEBUG			fprintf(stderr, "T_CONNECT\n");#endif        	OTRcvConnect(comm->endpoint, 0);        	comm->tcp_connected = 1;	        break;	        							case T_ORDREL:#if DEBUG			fprintf(stderr, "T_ORDREL\n");#endif			if(comm->tcp_connected){				OTRcvOrderlyDisconnect(comm->endpoint);				OTSndOrderlyDisconnect(comm->endpoint);			}else{				OTRcvOrderlyDisconnect(comm->endpoint);			}						comm->tcp_connected = 0;			if(callback){	        	(*callback)(comm, 0, 0, &source);	        }			break;					case T_DISCONNECT:#if DEBUG			fprintf(stderr, "T_DISCONNECT\n");#endif			OTRcvDisconnect(comm->endpoint, nil);			comm->tcp_connected = 0;			if(callback){	        	(*callback)(comm, 0, 0, &source);	        }			break;				case T_DISCONNECTCOMPLETE:#if DEBUG			fprintf(stderr, "T_DISCONNECTCOMPLETE\n");#endif			comm->tcp_connected = 0;			if(callback){	        	(*callback)(comm, 0, 0, &source);	        }			break;				        case T_DATA:		/* Standard data is available			*/            if(callback){            	OSStatus err;            	            	while(1){            		if((err = OTRcv(comm->endpoint, &localMsg.msg_size, sizeof(unsigned short), 0)) == sizeof(unsigned short)){            			if((err = OTRcv(comm->endpoint, &localMsg.msg, localMsg.msg_size, 0)) == localMsg.msg_size){					        (*callback)(comm, (char *)&localMsg.msg, localMsg.msg_size, &source);				        }				                    		}            		if(err < kOTNoDataErr){            			fprintf(stderr, "Error %d with OTRcv()\n", err);            			break;            		}            		if(err == kOTNoDataErr){            			break;            		}            	}            }            break;				case T_PASSCON:#if DEBUG			fprintf(stderr, "T_PASSCON\n");#endif			if(callback){	        	(*callback)(comm, 0, 1, &source);	        }			break;			        default:            printf("TCPClientEventHandler got unexpected event %ld\n", event);            break;    }    return;}#endif#pragma mark -#pragma mark *** Windows Helper Functions ***#ifdef TARGET_WINDOWSint tcp_accept(net_communication * comm){	int len;		len = sizeof(comm->client_address);	comm->client_socket = accept(comm->socket, (struct sockaddr *)&comm->client_address, &len);	if(comm->client_socket < 0)		return 0;		return 1;}unsigned int WINAPI communications_Thread(void * arg){	net_communication * comm = (net_communication *)arg;	net_address source;	struct sockaddr_in addr = {0};	int sourceSize = sizeof(struct sockaddr);	char buffer[kMaxMessage] = {0};	int dataSize = kMaxMessage;		while(1){		dataSize = kMaxMessage;		#if DEBUG		fprintf(stderr, "Waiting for a packet on %s!\n", stringNetworkAddress(getCommunicationAddress(comm)));#endif				dataSize = recvfrom(comm->socket, buffer, dataSize, 0, (struct sockaddr *)&addr, &sourceSize);		if(dataSize < 0){			fprintf(stderr, "Error %d with recvfrom\n", WSAGetLastError());			return 0;		}				buffer[dataSize] = 0;				source.port = ntohs(addr.sin_port);		*((unsigned long*)source.address) = addr.sin_addr.s_addr;				if(dataSize > 1){			void (*callback)(void * comm, char * buffer, unsigned int size, net_address * source) = 					(void (*)(void * comm, char * buffer, unsigned int size, net_address * source))comm->dataFunc;			if(callback){            	(*callback)(comm, buffer, dataSize, &source);            }		}else{			return 0;		}	}}unsigned int WINAPI communications_TCP_Listener_Thread(void * arg){	net_communication * comm = (net_communication *)arg;	net_address source = {0};	int dataSize = kMaxMessage;	msgRecord localMsg;			// Begin listening on this socket...	if(listen(comm->socket, 1)){		fprintf(stderr, "Error occured at listen() call\n");		return 0;	}		while(1){		void (*callback)(void * comm, char * buffer, unsigned int size, net_address * source) = 			(void (*)(void * comm, char * buffer, unsigned int size, net_address * source))comm->dataFunc;				// Waiting for a connection on port...		if(!tcp_accept(comm)){			fprintf(stderr, "Error occured during acceptTCP!\n");		}		comm->tcp_connected = 1;				source.port = comm->client_address.sin_port;		*((unsigned int *)source.address) = comm->client_address.sin_addr.s_addr;				// Call the callback with the buffer as zero... implies connection received...		if(callback){        	(*callback)(comm, 0, 0, &source);        }                // Proceed to read packets from the stream, calling the callback when the data comes in...    	while(1){    		if((dataSize = recv(comm->client_socket, (char *)&localMsg.msg_size, sizeof(unsigned short), 0)) == sizeof(unsigned short)){    			localMsg.msg_size = ntohs(localMsg.msg_size);    			dataSize = recv(comm->client_socket, (char *)&localMsg.msg, localMsg.msg_size, 0);		        (*callback)(comm, (char *)&localMsg.msg, localMsg.msg_size, &source);    		}        	if(dataSize <= 0){        		// communication with the client was broken... go back and accept another client...        		disconnectTCPServerCommunication(comm);        		fprintf(stderr, "Error %d with recv() from server\n", dataSize);        		break;    		}    	}  		comm->tcp_connected = 0;	}}unsigned int WINAPI communications_TCP_Connector_Thread(void * arg){	net_communication * comm = (net_communication *)arg;	void (*callback)(void * comm, char * buffer, unsigned int size, net_address * source) = 			(void (*)(void * comm, char * buffer, unsigned int size, net_address * source))comm->dataFunc;	net_address source = {0};	int dataSize = kMaxMessage;	msgRecord localMsg;			// Attempt to connect to the target		if(connect(comm->socket, (struct sockaddr *)&comm->address, sizeof(comm->address)) < 0){		fprintf(stderr, "Unable to connect to host (Error %d)\n", WSAGetLastError());        return 0;	}			// Call the callback with the buffer as zero... implies connection succeeded...	if(callback){    	(*callback)(comm, 0, 1, &source);    }				source.port = comm->address.sin_port;	*((unsigned int *)source.address) = comm->address.sin_addr.s_addr;	    // Proceed to read packets from the stream, calling the callback when the data comes in...	while(1){		if((dataSize = recv(comm->socket, (char *)&localMsg.msg_size, sizeof(unsigned short), 0)) == sizeof(unsigned short)){			localMsg.msg_size = ntohs(localMsg.msg_size);			dataSize = recv(comm->socket, (char *)&localMsg.msg, localMsg.msg_size, 0);	        (*callback)(comm, (char *)&localMsg.msg, localMsg.msg_size, &source);		}    	if(dataSize <= 0){    		// communication with the client was broken... go back and accept another client...    		disconnectTCPServerCommunication(comm);    		fprintf(stderr, "Error %d with recv() from client\n", dataSize);    		break;		}	}		// Call the callback with the buffer as zero... implies connection terminated...	if(callback){    	(*callback)(comm, 0, 0, &source);    }        return 0;}#endif#pragma mark -#pragma mark *** Hybrid Functions ***int initCommunication(net_communication * comm, net_address address, void (*dataFunc)(net_communication * comm, char * buffer, unsigned int size, net_address * source)){		#ifdef TARGET_MAC_CARBON	OSStatus 					status;	struct InetAddress 			reqAddr;	TBind						req, ret;	char 						inetStr[32];		memset(comm, 0, sizeof(net_communication));		/* Initialize all of OpenTransport */	/* Removed 11/24/02  OpenPlay handles this */	/*if(!OTpInited){	    status = InitOpenTransportInContext(kInitOTForApplicationMask, NULL);	    if (status < kOTNoError){	        fprintf(stderr, "InitOpenTransportInContext failed with error %ld.\n", status);	        return 0;	    }	    	    comm->status |= kOTActive;	    OTpInited = 1;    }*/        /* Create the Endpoint provider */    comm->endpoint = OTOpenEndpointInContext(OTCreateConfiguration(kUDPName), 0, NULL, &status, gOTClientContext);    if ((comm->endpoint == NULL) || (status < kOTNoError)){    	if(status == kENXIOErr)    		return 0;        fprintf(stderr, "OTOpenEndpointInContext failed with error %ld.\n", status);        return 0;    }        comm->status |= kOTEndpointCreated;            OTInitInetAddress(&comm->address, address.port, *((InetHost*)&address.address));    reqAddr.fAddressType = AF_INET;    reqAddr.fPort = address.port;    reqAddr.fHost = comm->address.fHost;    memset(&req, 0, sizeof(TBind));    req.addr.len = sizeof (struct InetAddress);    req.addr.buf = (UInt8*)&reqAddr;    req.qlen = 1;    memset(&comm->address, 0, sizeof(struct InetAddress));    memset(&ret, 0, sizeof(TBind));    ret.addr.maxlen = sizeof(struct InetAddress);    ret.addr.buf = (unsigned char *) &comm->address;        /* Set this endpoint so that you can reuse addresses */    SetFourByteOption(comm->endpoint, INET_IP, IP_REUSEADDR, true);        /* If this is a multicast address, set the multicasting option... */    /* 224.0.0.0 -> 239.255.255.255 */    if(address.address[0] >= 224 && address.address[0] < 240)	    setIPMulticastOption(comm->endpoint);        /* Bind the endpoint */    status = OTBind(comm->endpoint, &req, &ret);    if (status < kOTNoError){        fprintf(stderr, "OTBind failed with error %ld.\n", status);        return 0;    }else{        OTInetHostToString(comm->address.fHost, inetStr);#if DEBUG        fprintf(stderr, "UDP Endpoint bound to address %s, port %d.\n", inetStr, comm->address.fPort); #endif    }        comm->status |= kOTEndpointBound;            /* Setup the notifier so that everything can be done asynchronously */    comm->notifierUPP = NewOTNotifyUPP(EventHandler);    if (comm->notifierUPP == NULL){        fprintf(stderr, "NewOTNotifyUPP failed .\n");        return 0;    }            status = OTInstallNotifier(comm->endpoint, comm->notifierUPP, comm);    if (status < kOTNoError){        fprintf(stderr, "OTInstallNotifier failed with error %ld.\n", status);        return 0;    }        /* Set the endpoint into asynchonous mode */    status = OTSetAsynchronous(comm->endpoint);    if (status < kOTNoError){        fprintf(stderr, "OTSetAsynchronous failed with error %ld.\n", status);        return 0;    }    	comm->dataFunc = (void (*)(void * comm, char * buffer, unsigned int size, net_address * source))dataFunc;		#endif								#ifdef TARGET_WINDOWS    struct  protoent *protoEntry; // Protocol table entry    int reuseAddresses = 1;        if(windowsInited == 0){		WSADATA wsaData;	    WSAStartup(0x0101, &wsaData);    	windowsInited = 1;    }        memset(comm, 0, sizeof(net_communication));        if(address.port == 0)    	address.port = rand() % 45000 + 10000;	    comm->address.sin_family = AF_INET;    comm->address.sin_port = htons(address.port);    comm->address.sin_addr.s_addr = *((unsigned long*)address.address);    #if DEBUG    fprintf(stderr, "Attempting to create socket on address %s, port %d.\n", inet_ntoa(comm->address.sin_addr), ntohs(comm->address.sin_port)); #endif		// set this socket to use UDP	if((protoEntry = getprotobyname("udp")) == 0){		fprintf(stderr, "getprotobyname failed with \"udp\"\n");		return 0;	}		// Create the socket	comm->socket = socket(PF_INET, SOCK_DGRAM, protoEntry->p_proto);    if(comm->socket < 0) {        fprintf(stderr, "Unable to create the network socket\n");        return 0;    }        // Check and see if we are trying to bind to a multicast IP address...    if(address.address[0] >= 224 && address.address[0] < 240)				comm->address.sin_addr.s_addr = INADDR_ANY;         // Allow address reuse...    setsockopt(comm->socket, SOL_SOCKET, SO_REUSEADDR, (char *)&reuseAddresses, sizeof(int));                // Bind the socket    if(bind(comm->socket, (struct sockaddr *)&comm->address, sizeof(struct sockaddr)) < 0){    	fprintf(stderr, "Unable to bind the network socket (Error %d)\n", WSAGetLastError());        return 0;    }            // Check and see if we are trying to bind to a multicast IP address...    if(address.address[0] >= 224 && address.address[0] < 240){    	struct ip_mreq mreq;		mreq.imr_multiaddr.s_addr = inet_addr (stringNetworkAddress(address));		mreq.imr_interface.s_addr = INADDR_ANY;		setsockopt(comm->socket, IPPROTO_IP,IP_ADD_MEMBERSHIP,(char*)&mreq, sizeof(mreq));				comm->address.sin_addr.s_addr = INADDR_ANY;    }        // Restore the address so that the user can see it later (for the case of multicast addresses    comm->address.sin_addr.s_addr = *((unsigned long*)address.address);    #if DEBUG    fprintf(stderr, "UDP Socket bound to address %s, port %d.\n", inet_ntoa(comm->address.sin_addr), ntohs(comm->address.sin_port)); #endif		comm->dataFunc = (void (*)(void * comm, char * buffer, unsigned int size, net_address * source))dataFunc;		// Launch the asynchronous thread which handles listening on this communication...	comm->commThread = (HANDLE)_beginthreadex(NULL, 0, communications_Thread, comm, 0, &comm->commThreadID);	if(!comm->commThread){		fprintf(stderr, "Error: Unable to launch network listener thread\n");        return 0;	}		#endif			return 1;}void closeCommunication(net_communication * comm){	#ifdef TARGET_MAC_CARBON	OTCloseProvider(comm->endpoint);	#endif		#ifdef TARGET_WINDOWS	DWORD status;	TerminateThread(comm->commThread, 0);	while(GetExitCodeThread(comm->commThread, &status) == STILL_ACTIVE){};		shutdown(comm->socket, 0x00);	closesocket(comm->socket);	CloseHandle(comm->commThread);	#endif}net_address getCommunicationAddress(net_communication * comm){	net_address n;		#ifdef TARGET_MAC_CARBON		n.port = comm->address.fPort;	*((unsigned int *)n.address) = comm->address.fHost;		return n;	#endif		#ifdef TARGET_WINDOWS	n.port = comm->address.sin_port;	*((unsigned int *)n.address) = comm->address.sin_addr.s_addr;	return n;	#endif}#pragma mark -int compareNetworkAddresses(net_address a, net_address b){	#ifdef TARGET_MAC_CARBON	return memcmp(&a.address, &b.address, sizeof(b.address));	#endif		#ifdef TARGET_WINDOWS	return memcmp(&a.address, &b.address, sizeof(b.address));	#endif}net_address makeNetworkAddress(char * address, unsigned short port){	net_address n = {0};		#ifdef TARGET_MAC_CARBON	OTInetStringToHost(address, (unsigned long *)n.address);	n.port = port;	#endif		#ifdef TARGET_WINDOWS	*((unsigned long *)n.address) = inet_addr(address);	n.port = port;	#endif		return n;}net_address defaultNetworkAddress(unsigned short port){	net_address n = {0};		#ifdef TARGET_MAC_CARBON	InetInterfaceInfo inetInfo;	OSStatus status;		/* get the primary interface inet info */    status = OTInetGetInterfaceInfo(&inetInfo, kDefaultInetInterface);    if (status < kOTNoError){        return n;    }    memcpy(n.address, &inetInfo.fAddress, sizeof(inetInfo.fAddress));	n.port = port;	#endif		#ifdef TARGET_WINDOWS	char buf[256] = {0};	hostent * entry;		if(windowsInited == 0){		WSADATA wsaData;	    WSAStartup(0x0101, &wsaData);    	windowsInited = 1;    }		if(gethostname(buf, 256) == -1){		return n;	}	entry = gethostbyname(buf);		memcpy(n.address, entry->h_addr, sizeof(in_addr));	n.port = port;	#endif		return n;}char * stringNetworkAddress(net_address addr){	static char buf[64] = {0};		#ifdef TARGET_MAC_CARBON	OTInetHostToString(*((unsigned int *)addr.address), buf);	#endif		#ifdef TARGET_WINDOWS	memset(buf, 0, 64);	strcpy(buf, inet_ntoa(*((in_addr *)addr.address)));	#endif		return buf;}#pragma mark -int sendNetworkPacket(net_communication * comm, char * data, unsigned int size, net_address target){		#ifdef TARGET_MAC_CARBON		struct InetAddress address;	TUnitData sendData;	OSStatus status;		OTInitInetAddress(&address, target.port, *((InetHost*)&target.address));		sendData.addr.len = sizeof(struct InetAddress);	sendData.addr.buf = (UInt8*) &address;				sendData.opt.len = 0;	sendData.opt.buf = 0;	sendData.udata.len = size;	sendData.udata.buf = (UInt8*)data;		status = OTSndUData(comm->endpoint, &sendData);	if (status < kOTNoError){        fprintf(stderr, "Error sending data - %ld\n", status);        return 0;    }    #if DEBUG	fprintf(stderr, "%d bytes sent to %s!\n", size, stringNetworkAddress(target));#endif        #endif            #ifdef TARGET_WINDOWS    struct sockaddr_in addr = {0};        addr.sin_family = AF_INET;    addr.sin_port = htons(target.port);    addr.sin_addr.s_addr = inet_addr (stringNetworkAddress(target));    	sendto(comm->socket, data, size, 0, (struct sockaddr *)&addr, sizeof(struct sockaddr));	#if DEBUG	fprintf(stderr, "%d bytes sent to %s.%d!\n", size, stringNetworkAddress(target), target.port);#endif    #endif                comm->packetsSent++;    return 1;}int recvNetworkPacket(net_communication * comm, char * buffer, unsigned int size, net_address * source){	#ifdef TARGET_MAC_CARBON		TUnitData			unitdata;	struct InetAddress  sourceAddress;	OTResult 			result;	UInt32				flag;				unitdata.addr.maxlen = sizeof(struct InetAddress);	unitdata.opt.maxlen = 0;	unitdata.opt.buf = 0;	unitdata.udata.maxlen = size;	unitdata.udata.buf = (unsigned char *)buffer;	unitdata.addr.buf = (UInt8*) &sourceAddress;	result = OTRcvUData(comm->endpoint, &unitdata, &flag);		if(result < kOTNoError)		return 0;		source->port = sourceAddress.fPort;	*((unsigned int *)source->address) = sourceAddress.fHost;		size = unitdata.udata.len;		#endif				#ifdef TARGET_WINDOWS		struct sockaddr_in addr = {0};	int sourceSize = sizeof(struct sockaddr);	size = recvfrom(comm->socket, buffer, size, 0, (struct sockaddr *)&addr, &sourceSize);			source->port = ntohs(addr.sin_port);	*((unsigned long*)source->address) = addr.sin_addr.s_addr;		#endif		comm->packetsReceived++;	return size;}#pragma mark -NetLock * createLock(){	NetLock * ptr = (NetLock *)malloc(sizeof(NetLock));	#ifdef TARGET_WINDOWS	ptr->lock = CreateMutex(0, 0, 0);	#endif		#ifdef TARGET_MAC_CARBON	ptr->lock = 0;	#endif		return ptr;}void destructLock(NetLock * lock){	#ifdef TARGET_WINDOWS	CloseHandle(lock->lock);	#endif		#ifdef TARGET_MAC_CARBON		#endif		free(lock);}void aquireLock(NetLock * lock){	#ifdef TARGET_WINDOWS	WaitForSingleObject(lock->lock, INFINITE);	#endif		#ifdef TARGET_MAC_CARBON	while(!OTAcquireLock(&lock->lock)){};	#endif}void releaseLock(NetLock * lock){	#ifdef TARGET_WINDOWS	ReleaseMutex(lock->lock);	#endif		#ifdef TARGET_MAC_CARBON	OTClearLock(&lock->lock);	#endif}void enterCriticalSection(net_communication * comm){	#ifdef TARGET_MAC_CARBON	OTEnterNotifier(comm->endpoint);	#endif}void leaveCriticalSection(net_communication * comm){	#ifdef TARGET_MAC_CARBON	OTLeaveNotifier(comm->endpoint);	#endif}#pragma mark -#pragma mark *** TCP Functions ***/* TCP specific functions.  Handles the different caveats which TCP has as opposed * to how UDP works, such as making and listening for connections and so forth. */int initTCPServerCommunication(net_communication * comm, net_address address, void (*dataFunc)(net_communication * comm, char * buffer, unsigned int size, net_address * source))/* Create a passive communications instance which listens to incomming communications. * Only handles one client at a time... ideal in this particular situation */{	#ifdef TARGET_MAC_CARBON	OSStatus 					status;	struct InetAddress 			reqAddr;	TBind						req, ret;	char 						inetStr[32];		memset(comm, 0, sizeof(net_communication));		/* Initialize all of OpenTransport */	/* Removed 11/24/02   OpenPlay handles this */	/*if(!OTpInited){	    status = InitOpenTransportInContext(kInitOTForApplicationMask, NULL);	    if (status < kOTNoError){	        fprintf(stderr, "InitOpenTransportInContext failed with error %ld.\n", status);	        return 0;	    }	    	    comm->status |= kOTActive;	    OTpInited = 1;    }*/        /* Create the Endpoint provider */    comm->endpoint = OTOpenEndpointInContext(OTCreateConfiguration("tilisten, tcp"), 0, NULL, &status, gOTClientContext);    if ((comm->endpoint == NULL) || (status < kOTNoError)){    	if(status == kENXIOErr)    		return 0;        fprintf(stderr, "OTOpenEndpointInContext failed with error %ld.\n", status);        return 0;    }        /* Create the client endpoint provider */    comm->client_endpoint = OTOpenEndpointInContext(OTCreateConfiguration("tilisten, tcp"), 0, NULL, &status, gOTClientContext);    if ((comm->endpoint == NULL) || (status < kOTNoError)){    	if(status == kENXIOErr)    		return 0;        fprintf(stderr, "OTOpenEndpointInContext failed with error %ld.\n", status);        return 0;    }        comm->status |= kOTEndpointCreated;            OTInitInetAddress(&comm->address, address.port, *((InetHost*)&address.address));    reqAddr.fAddressType = AF_INET;    reqAddr.fPort = address.port;    reqAddr.fHost = comm->address.fHost;    memset(&req, 0, sizeof(TBind));    req.addr.len = sizeof (struct InetAddress);    req.addr.buf = (UInt8*)&reqAddr;    req.qlen = 1;    memset(&comm->address, 0, sizeof(struct InetAddress));    memset(&ret, 0, sizeof(TBind));    ret.addr.maxlen = sizeof(struct InetAddress);    ret.addr.buf = (unsigned char *) &comm->address;        /* Set this endpoint so that you can reuse addresses */    SetFourByteOption(comm->endpoint, INET_IP, IP_REUSEADDR, true);    SetFourByteOption(comm->endpoint, INET_TCP, TCP_NODELAY, 1);            /* Bind the endpoint */    status = OTBind(comm->endpoint, &req, &ret);    if (status < kOTNoError){        fprintf(stderr, "OTBind failed with error %ld.\n", status);        return 0;    }else{        OTInetHostToString(comm->address.fHost, inetStr);#if DEBUG        fprintf(stderr, "TCP Server Endpoint bound to address %s, port %d.\n", inetStr, comm->address.fPort); #endif    }            while(comm->endpoint->GetEndpointState() == kOTStateChangeErr)		OTIdle();        comm->status |= kOTEndpointBound;            /* Setup the notifier so that everything can be done asynchronously */    comm->notifierUPP = NewOTNotifyUPP(TCPServerEventHandler);    if (comm->notifierUPP == NULL){        fprintf(stderr, "NewOTNotifyUPP failed .\n");        return 0;    }            status = OTInstallNotifier(comm->endpoint, comm->notifierUPP, comm);    if (status < kOTNoError){        fprintf(stderr, "OTInstallNotifier failed with error %ld.\n", status);        return 0;    }        status = OTInstallNotifier(comm->client_endpoint, comm->notifierUPP, comm);    if (status < kOTNoError){        fprintf(stderr, "OTInstallNotifier failed with error %ld.\n", status);        return 0;    }        /* Set the endpoint into asynchonous mode */    status = OTSetAsynchronous(comm->endpoint);    if (status < kOTNoError){        fprintf(stderr, "OTSetAsynchronous failed with error %ld.\n", status);        return 0;    }        status = OTSetAsynchronous(comm->client_endpoint);    if (status < kOTNoError){        fprintf(stderr, "OTSetAsynchronous failed with error %ld.\n", status);        return 0;    }    	comm->dataFunc = (void (*)(void * comm, char * buffer, unsigned int size, net_address * source))dataFunc;		#endif				#ifdef TARGET_WINDOWS    struct  protoent *protoEntry; // Protocol table entry    int reuseAddresses = 1;    int nodelay = 1;        if(windowsInited == 0){		WSADATA wsaData;	    WSAStartup(0x0101, &wsaData);    	windowsInited = 1;    }        memset(comm, 0, sizeof(net_communication));        if(address.port == 0)    	address.port = rand() % 45000 + 10000;	    comm->address.sin_family = AF_INET;    comm->address.sin_port = htons(address.port);    comm->address.sin_addr.s_addr = *((unsigned long*)address.address);    #if DEBUG    fprintf(stderr, "Attempting to create socket on address %s, port %d.\n", inet_ntoa(comm->address.sin_addr), ntohs(comm->address.sin_port)); #endif		// set this socket to use UDP	if((protoEntry = getprotobyname("tcp")) == 0){		fprintf(stderr, "getprotobyname failed with \"tcp\"\n");		return 0;	}		// Create the socket	comm->socket = socket(PF_INET, SOCK_STREAM, protoEntry->p_proto);    if(comm->socket < 0) {        fprintf(stderr, "Unable to create the network socket\n");        return 0;    }        	// Allow address reuse...    setsockopt(comm->socket, SOL_SOCKET, SO_REUSEADDR, (char *)&reuseAddresses, sizeof(int));    // No Delay of packets...    setsockopt(comm->socket, SOL_SOCKET, TCP_NODELAY, (char *)&nodelay, sizeof(int));                // Bind the socket    if(bind(comm->socket, (struct sockaddr *)&comm->address, sizeof(struct sockaddr)) < 0){    	fprintf(stderr, "Unable to bind the TCP server network socket (Error %d)\n", WSAGetLastError());        return 0;    }        #if DEBUG    fprintf(stderr, "TCP Server Socket bound to address %s, port %d.\n", inet_ntoa(comm->address.sin_addr), ntohs(comm->address.sin_port)); #endif		comm->dataFunc = (void (*)(void * comm, char * buffer, unsigned int size, net_address * source))dataFunc;		// Launch a separate thread to listen for connections	comm->commThread = (HANDLE)_beginthreadex(NULL, 0, communications_TCP_Listener_Thread, comm, 0, &comm->commThreadID);	if(!comm->commThread){		fprintf(stderr, "Error: Unable to launch network listener thread\n");        return 0;	}		#endif		return 1;}void disconnectTCPServerCommunication(net_communication * comm){	#ifdef TARGET_MAC_CARBON	if(comm->tcp_connected)		OTSndDisconnect(comm->client_endpoint, &comm->client_call);	#endif		#ifdef TARGET_WINDOWS	if(comm->tcp_connected){		shutdown(comm->client_socket, 0x00);		closesocket(comm->client_socket);		comm->tcp_connected = 0;	}	#endif}void closeTCPServerCommunication(net_communication * comm){	#ifdef TARGET_MAC_CARBON	if(comm->tcp_connected)		disconnectTCPServerCommunication(comm);	OTCloseProvider(comm->endpoint);	OTCloseProvider(comm->client_endpoint);	#endif		#ifdef TARGET_WINDOWS		DWORD status;	TerminateThread(comm->commThread, 0);	while(GetExitCodeThread(comm->commThread, &status) == STILL_ACTIVE){};	shutdown(comm->socket, 0x00);	closesocket(comm->socket);		if(comm->tcp_connected){		shutdown(comm->client_socket, 0x00);		closesocket(comm->client_socket);	}	#endif}int tcpServerSendPacket(net_communication * comm, char * data, unsigned int size){	globalMsg.msg_size = size;	memcpy(globalMsg.msg, data, size);			#ifdef TARGET_MAC_CARBON	OTResult err;	if((err = OTSnd(comm->client_endpoint, &globalMsg, size + sizeof(unsigned short), 0)) < kOTNoError){		if(err != kOTOutStateErr)			fprintf(stderr, "Error %d occured during send(%20s)\n", err, data);    	return 0;	}		    #endif            #ifdef TARGET_WINDOWS    globalMsg.msg_size = htons(globalMsg.msg_size);    if(send(comm->client_socket, (char *)&globalMsg, size + sizeof(unsigned short), 0) < 0){		fprintf(stderr, "Error occured during send(%20s)\n", data);    	return 0;    }        #endif        comm->packetsSent++;    return 1;}#pragma mark -int initTCPConnection(net_communication * comm, net_address target, void (*dataFunc)(net_communication * comm, char * buffer, unsigned int size, net_address * source)){			#ifdef TARGET_MAC_CARBON	OSStatus 					status;	TBind						ret;	TCall 						call;	char 						inetStr[32];		memset(comm, 0, sizeof(net_communication));		/*********** Initialize all of OpenTransport ***********/	/* Removed 11/24/02   OpenPlay handles this */	/*if(!OTpInited){	    status = InitOpenTransportInContext(kInitOTForApplicationMask, NULL);	    if (status < kOTNoError){	        fprintf(stderr, "InitOpenTransportInContext failed with error %ld.\n", status);	        return 0;	    }	    	    comm->status |= kOTActive;	    OTpInited = 1;    }*/        /*********** Create the Endpoint provider ***********/    comm->endpoint = OTOpenEndpointInContext(OTCreateConfiguration("tilisten, tcp"), 0, NULL, &status, gOTClientContext);    if ((comm->endpoint == NULL) || (status < kOTNoError)){    	if(status == kENXIOErr)    		return 0;        fprintf(stderr, "OTOpenEndpointInContext failed with error %ld.\n", status);        return 0;    }            comm->status |= kOTEndpointCreated;            /*********** Bind the endpoint ***********/    memset(&comm->address, 0, sizeof(struct InetAddress));    memset(&ret, 0, sizeof(TBind));    ret.addr.maxlen = sizeof(struct InetAddress);    ret.addr.buf = (unsigned char *) &comm->address;            status = OTBind(comm->endpoint, 0, &ret);    if (status < kOTNoError){        fprintf(stderr, "OTBind failed with error %ld.\n", status);        return 0;    }else{        OTInetHostToString(comm->address.fHost, inetStr);#if DEBUG        fprintf(stderr, "TCP Client Endpoint bound to address %s, port %d.\n", inetStr, comm->address.fPort); #endif    }        comm->status |= kOTEndpointBound;            /*********** Setup the notifier so that everything can be done asynchronously ***********/    comm->notifierUPP = NewOTNotifyUPP(TCPClientEventHandler);    if (comm->notifierUPP == NULL){        fprintf(stderr, "NewOTNotifyUPP failed .\n");        return 0;    }            status = OTInstallNotifier(comm->endpoint, comm->notifierUPP, comm);    if (status < kOTNoError){        fprintf(stderr, "OTInstallNotifier failed with error %ld.\n", status);        return 0;    }        /*********** Set the endpoint into asynchonous mode ***********/    status = OTSetAsynchronous(comm->endpoint);    if (status < kOTNoError){        fprintf(stderr, "OTSetAsynchronous failed with error %ld.\n", status);        return 0;    }        	comm->dataFunc = (void (*)(void * comm, char * buffer, unsigned int size, net_address * source))dataFunc;			/*********** Attempt to connect to the client ***********/    OTInitInetAddress(&comm->address, target.port, *((InetHost*)&target.address));		memset(&call, 0, sizeof(TCall));	call.addr.maxlen = sizeof(struct InetAddress);	call.addr.len = sizeof(struct InetAddress);	call.addr.buf = (unsigned char *) &comm->address;	call.opt.maxlen = 0;	call.opt.buf = 0;	call.udata.maxlen = 0;	status = OTConnect(comm->endpoint, &call, 0);		#endif							#ifdef TARGET_WINDOWS    struct  protoent *protoEntry; // Protocol table entry        if(windowsInited == 0){		WSADATA wsaData;	    WSAStartup(0x0101, &wsaData);    	windowsInited = 1;    }        memset(comm, 0, sizeof(net_communication));        comm->address.sin_family = AF_INET;    comm->address.sin_port = htons(target.port);    comm->address.sin_addr.s_addr = *((unsigned long*)target.address);        // set this socket to use TCP	if((protoEntry = getprotobyname("tcp")) == 0){		fprintf(stderr, "getprotobyname failed with \"tcp\"\n");		return 0;	}    			// Create the socket	comm->socket = socket(PF_INET, SOCK_STREAM, protoEntry->p_proto);    if(comm->socket < 0) {        fprintf(stderr, "Unable to create the network socket\n");        return 0;    }    #if DEBUG    fprintf(stderr, "TCP Client Socket bound to address %s, port %d.\n", inet_ntoa(comm->address.sin_addr), ntohs(comm->address.sin_port)); #endif    	comm->dataFunc = (void (*)(void * comm, char * buffer, unsigned int size, net_address * source))dataFunc;	// Launch a separate thread to listen for connections	comm->commThread = (HANDLE)_beginthreadex(NULL, 0, communications_TCP_Connector_Thread, comm, 0, &comm->commThreadID);	if(!comm->commThread){		fprintf(stderr, "Error: Unable to launch network listener thread\n");        return 0;	}		#endif		return 1;}void closeTCPClientCommunication(net_communication * comm){	closeCommunication(comm);}int tcpClientSendPacket(net_communication * comm, char * data, unsigned int size){	globalMsg.msg_size = size;	memcpy(globalMsg.msg, data, size);		#ifdef TARGET_MAC_CARBON	OTResult err;	if((err = OTSnd(comm->endpoint, &globalMsg, size + sizeof(unsigned short), 0)) < kOTNoError){		if(err != kOTOutStateErr)			fprintf(stderr, "Error %d occured during send(%20s)\n", err, data);    	return 0;	}    #endif            #ifdef TARGET_WINDOWS    globalMsg.msg_size = htons(globalMsg.msg_size);    if(send(comm->socket, (char *)&globalMsg, size + sizeof(unsigned short), 0) < 0){    	fprintf(stderr, "Error occured during send()\n");    	return 0;    }        #endif        comm->packetsSent++;    return 1;}