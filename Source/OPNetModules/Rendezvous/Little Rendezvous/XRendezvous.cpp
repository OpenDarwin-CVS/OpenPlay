/*	11/14/02 * *	Rocco Bowling *	Feline Entertainment *	http://homepage.mac.com/felinegames *	http://homepage.mac.com/felinegames/games/thebelt/index.html *	felinegames@mac.com *	 *	This source code is part of The Belt, my entry in the 2002 uDevGame Mac Game Programming *	contest (refer to www.idevgames.com for more details).  My main goal for The Belt in  *	relation to the purpose of the contest was to create a game which was cross platform *	Mac and Windows from the same CodeWarrior project, without relying on third-party *	cross platform libraries.  Hence, in the bowels of this code you will find functions *	which handle the Mac case, as well as the functions which handles the Windows case. *	Most of the cross platform issues are encapsulated in the engine code, which allows *	you to modify The Belt itself in an easy, platform independent manner.  The Belt *	is also an example of good program design, with modular pieces of code, as well *	as centralized object and application managers. * *	For the record, this program is provided on an "as-is" basis for educational purposes *	only.  The source code is subject to the uDevGame Source Code License, so please refer *	to that if you have any questions. * *	If you have any questions specific to the code, feel free to send me an email. *//* XRendezvous * * Cross-platform Rendezvous-like code which does not require an outside library * * Works on OS 9, OS X, and Windows... * * Why not full-fledged Rendezvous? *		For starters, it is impossible to write your own Rendevous server to run on OS 10.2 because it *	would interfere with the server already running on 10.2, and I wanted one code set to run on all of * 	the platforms supported.  The second reason is that Rendezvous is a very general purpose API which *	needs to handle a lot of stuff.  Since this code is meant only for game finding on a single subnet, *	we can throw out much of the specification.  For instance, we only want out Rendezvous server to be *	published and responsive on the chat screen/game finding screen.  While the game is playing we do not *	need advertise to others for a game.  Also, we can be fairly certain that there will not be more than *	a couple hundred players on a single subnet, so we can emulate the old AppleTalk and "ping" for names *	every few seconds on so (I don't currentl do this, but we could). * * How does it work? *		Rendezvous is made to work with existing protocols for everyone, hence they use DNS queries over *	a multicast address.  In this slimmed-down Rendezvous, we use the same multicast address as Rendezvous * 	but we communicate on port 53535 (Rendezvous uses 5353) so we don't interfere with regular Rendezvous. *	When a program which uses this API starts, they need to call initRendezvousManager() which starts up the *	listener which listens to the multicast address.  Then, the program calls createNewService() to have a *	service advertised across the network.  createNewService() sends a packet with the control tag *	kAdvertisement out to the multicast address, telling everyone else that another service just came onto *	the network so that they can update there lists. * */#pragma mark *** Includes ***#include <time.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include "XRendezvous.h"#include "XNetwork.h"#pragma mark *** Definitions ***#define kMaxServices 255typedef struct{	char type[64];	char name[64];	net_address address;}serviceInfo;enum{	kServiceRequest = 0,	kServiceAdvertisement,	kServiceRemoved};#pragma mark *** Globals ***static int endpointIsBound = 0;static net_communication multicastServerComm = {0};static net_communication serviceLookupComm = {0};static void (*serviceLookupCallback)(char * name, net_address address) = 0;static char serviceLookupArray[64] = {0};static xr_service serviceArray[20] = {0};static int numServices = 0;static serviceInfo servicesFoundArray[kMaxServices] = {0};static int numServicesFound = 0;static int rendezvousInited = 0;#pragma mark *** Prototypes ***static xr_service * getServiceOfType(char * type);static char * getServiceTypeFromURL(char * url);static char * getServiceNameFromURL(char * url);static unsigned short getServicePortFromURL(char * url);static void processSinglePacket(net_communication * comm, char * buffer, unsigned int size, net_address * source);static void addServiceToList(char * type, char * name, net_address * address);static void removeServiceFromList(char * type, char * name, net_address * address);#pragma mark *** Code ***void destructRendezvousManager(){	if(!rendezvousInited)		return;#if DEBUG	fprintf(stderr, "Multicast Server received %d packets\n", multicastServerComm.packetsReceived);	fprintf(stderr, "Multicast Server sent %d packets\n", multicastServerComm.packetsSent);	fprintf(stderr, "Service Lookup received %d packets\n", serviceLookupComm.packetsReceived);	fprintf(stderr, "Service Lookup sent %d packets\n", serviceLookupComm.packetsSent);#endif	for(int i = 0; i < numServices; i++){		removeService(serviceArray[i].type);	}		closeCommunication(&multicastServerComm);	closeCommunication(&serviceLookupComm);		rendezvousInited = 0;}int initRendezvousManager()/* Basically, create a "socket" to listen on UDP port 53535 */{	if(rendezvousInited)		return 0;		endpointIsBound = 0;	numServices = 0;	numServicesFound = 0;		memset(serviceLookupArray, 0, 64);	memset(serviceArray, 0, sizeof(xr_service) * 20);	memset(servicesFoundArray, 0, sizeof(serviceInfo) * kMaxServices);	    if(!initCommunication(&multicastServerComm, makeNetworkAddress("224.0.0.251", 53535), processSinglePacket)){    	return 0;    }        serviceLookupCallback = 0;    numServices = 0;    numServicesFound = 0;        /* Special call to init the service manager */    lookupService(0, 0);        rendezvousInited = 1;            return 1;}void processSinglePacket(net_communication * comm, char * buffer, unsigned int size, net_address * source){	xr_service * servicePtr;	char portBuf[12];		#pragma unused (comm, size)		/*	Check to see if this packet originated from this computer.	 *	If it did, we want to ignore since this is a protocol which	 *	provides a name service between different computer, not	 *	applications on the same computer.	 */	 	if(compareNetworkAddresses(getCommunicationAddress(&serviceLookupComm), *source)){		/* show the bytes which were received. */		switch(*buffer){			case kServiceRequest:#if DEBUG				fprintf(stderr, "Looking up service %s\n", getServiceTypeFromURL(buffer+1));#endif				servicePtr = getServiceOfType(getServiceTypeFromURL(buffer+1));				if(servicePtr){			        *buffer = kServiceAdvertisement;			        buffer[1] = 0;			        			        sprintf(portBuf, ".%u", servicePtr->port);			        			        strcat(buffer+1, servicePtr->type);					strcat(buffer+1, servicePtr->name);					strcat(buffer+1, portBuf);    			    			        sendNetworkPacket(&serviceLookupComm, buffer, strlen(buffer+1)+1, *source);#if DEBUG					fprintf(stderr, "Sending reply to %s\n", stringNetworkAddress(*source));#endif				}				break;			case kServiceAdvertisement:				// Check to see if this is the type of service we are looking for...				// Needed since when a computer creates a new service, it multicasts it				// to the network (to say "Hi"), hence we may receive misc advertisements				// across this multicast address.				if(serviceLookupCallback){					if(!strcmp(serviceLookupArray, getServiceTypeFromURL(buffer+1))){						unsigned short port = getServicePortFromURL(buffer+1);						if(port)							source->port = port;						(*serviceLookupCallback)(getServiceNameFromURL(buffer+1), *source);						addServiceToList(serviceLookupArray, getServiceNameFromURL(buffer+1), source);					}				}				break;			case kServiceRemoved:								if(serviceLookupCallback){					if(!strcmp(serviceLookupArray, getServiceTypeFromURL(buffer+1))){						/******** WARNING ********/						/* 						 * Added the following call for the OpenPlay module only so that the						 * Enumeration will be refreshed properly...						 * 						 */						(*serviceLookupCallback)(getServiceNameFromURL(buffer+1), *source);						removeServiceFromList(serviceLookupArray, getServiceNameFromURL(buffer+1), source);					}				}								break;		}	}		}#pragma mark -#pragma mark *** Responder Functions ***xr_service createNewService(char * domain, char * type, char * name, short port){	net_address target = makeNetworkAddress("224.0.0.251", 53535);	xr_service n = {0};	char buffer[1024] = {0};	char portBuf[12];	//char buf[64];		if(!rendezvousInited)		return n;		//sprintf(buf, ".%06d", rand() % 999999);		strcpy(n.domain, domain);	strcpy(n.type, type);	strcpy(n.name, name);	//strcat(n.name, buf);	n.port = port;		serviceArray[numServices] = n;	numServices++;		// Multicast this service onto the network...    *buffer = kServiceAdvertisement;        sprintf(portBuf, ".%u", n.port);        strcat(buffer+1, n.type);	strcat(buffer+1, n.name);	strcat(buffer+1, portBuf);        /* Now, send the service name as the payload for the udp packet... */ 	sendNetworkPacket(&serviceLookupComm, buffer, strlen(buffer+1)+1, target);		return n;}void removeService(char * type){	net_address target = makeNetworkAddress("224.0.0.251", 53535);	char buffer[1024] = {0};	xr_service removeMe;		for(int i = 0; i < numServices; i++){		if(!strcmp(serviceArray[i].type, type)){			// Remove this service!			removeMe = serviceArray[i];						for(int j = i; j < numServices-1; j++){				serviceArray[j] = serviceArray[j+1];			}						// Send the multicast packet across the network...			*buffer = kServiceRemoved;		    strcat(buffer+1, removeMe.type);		    strcat(buffer+1, removeMe.name);		    			sendNetworkPacket(&serviceLookupComm, buffer, strlen(buffer+1)+1, target);						numServices--;		}	}}void setServerErrorCallback(xr_service * service, void (*ptr)(char *)){	service->errorPtr = ptr;}void setServerResultCallback(xr_service * service, void (*ptr)(int i)){	service->resultPtr = ptr;}xr_service * getServiceOfType(char * type){	int i;	for(i = 0; i < numServices; i++){		if(!strcmp(serviceArray[i].type, type))			return serviceArray+i;	}	return 0;}char * getServiceTypeFromURL(char * url){	static char buffer[128];	char * ptr = strchr(strchr(url, '.')+1, '.');		memset(buffer, 0, 128);		if(!ptr){		*buffer = 0;		return buffer;	}		*ptr = 0;	strcpy(buffer, url);	*ptr = '.';		strcat(buffer, ".");		return buffer;}char * getServiceNameFromURL(char * url){	static char buffer[128] = {0};	char * ptr = strchr(strchr(url, '.')+1, '.');	char * lptr = strrchr(url+1, '.');		memset(buffer, 0, 128);		if(!ptr){		*buffer = 0;		return buffer;	}		*lptr = 0;		ptr++;	strcpy(buffer, ptr);		*lptr = '.';		return buffer;}unsigned short getServicePortFromURL(char * url){	unsigned int port = 0;	char * ptr = strrchr(url+1, '.');		if(!ptr){		return 0;	}		ptr++;	sscanf(ptr, "%u", &port);			return port;}#pragma mark -#pragma mark *** Service List Handling Functions ***static int isServiceInList(char * name){	for(int i = 0; i < numServicesFound; i++){		if(!strcpy(servicesFoundArray[i].name, name)){			return 1;		}	}	return 0;}void addServiceToList(char * type, char * name, net_address * address){	if(!strcmp(serviceLookupArray, type) && numServicesFound < kMaxServices){		if(!isServiceInList(name)){			strcpy(servicesFoundArray[numServicesFound].type, serviceLookupArray);			servicesFoundArray[numServicesFound].address = *address;			strcpy(servicesFoundArray[numServicesFound].name, name);			numServicesFound++;		}	}}void removeServiceFromList(char * type, char * name, net_address * address){	if(!strcmp(serviceLookupArray, type) && numServicesFound < kMaxServices){		for(int i = 0; i < numServicesFound; i++){			if(!compareNetworkAddresses(servicesFoundArray[i].address, *address)){				if(!strcmp(name, servicesFoundArray[i].name)){					// Ok, remove this one!										for(int j = i; j < numServicesFound-1; j++){						servicesFoundArray[j] = servicesFoundArray[j+1];					}										numServicesFound--;				}			}		}	}}static int serviceFoundCounter;int getFirstServiceFound(char name[64], net_address * address){	serviceFoundCounter = 0;		if(numServicesFound == 0)		return 0;		strcpy(name, servicesFoundArray[0].name);	*address = servicesFoundArray[0].address;		return 1;}int getNextServiceFound(char name[64], net_address * address){	serviceFoundCounter++;		if(serviceFoundCounter >= numServicesFound){		serviceFoundCounter--;		return 0;	}		strcpy(name, servicesFoundArray[serviceFoundCounter].name);	*address = servicesFoundArray[serviceFoundCounter].address;		return 1;}int getNumberOfServicesFound(){	return numServicesFound;}char * getServiceName(xr_service * srv){	return srv->name;}#pragma mark -#pragma mark *** Request Functions ***static void processSingleServicePacket(net_communication * comm, char * buffer, unsigned int size, net_address * source){	#pragma unused (comm, size)			switch(*buffer){		case kServiceAdvertisement:			if(serviceLookupCallback){				// Check to see if this is the type of service we are looking for...				// Redundant check since any service which is sent straight to us is only in				// response to our own query				if(!strcmp(serviceLookupArray, getServiceTypeFromURL(buffer+1))){					unsigned short port = getServicePortFromURL(buffer+1);					if(port)						source->port = port;					(*serviceLookupCallback)(getServiceNameFromURL(buffer+1), *source);					addServiceToList(serviceLookupArray, getServiceNameFromURL(buffer+1), source);				}			}			break;	}}int lookupService(char * service, void (*ptr)(char * name, net_address)){	net_address target = makeNetworkAddress("224.0.0.251", 53535);	char buffer[1024];			serviceLookupCallback = ptr;		if(endpointIsBound == 0){		/* We only need to create and bind this endpoint once... */				if(!initCommunication(&serviceLookupComm, defaultNetworkAddress(0), processSingleServicePacket))			return 0;			    	    endpointIsBound = 1;    }        if(service == 0)    	return 1;        *buffer = kServiceRequest;	strcpy(buffer+1, service);		strcpy(serviceLookupArray, service);        /* Now, send the service name as the payload for the udp packet... */ 	sendNetworkPacket(&serviceLookupComm, buffer, strlen(buffer+1)+1, target);	        return 1;}#pragma mark -#pragma mark *** MacOS Helper Functions ***#ifdef TARGET_MAC_CARBONstatic UInt32 gMoreCSSystemVersion = 0;enum {    kMoreCSMacOSX10point0 = 0x01000,    kMoreCSMacOSX10point1 = 0x01010,    kMoreCSMacOSX10point2 = 0x01020};static CFStringRef CreateCFStringFromStringResource(SInt16 rsrcID){    CFStringRef result;    SInt8       s;    Handle      stringH;    result = nil;    stringH = GetResource('STR ', rsrcID);    if (stringH != nil) {        s = HGetState(stringH);        HLock(stringH);        result = CFStringCreateWithPascalString(kCFAllocatorSystemDefault,                                                (StringPtr) *stringH,                                                CFStringGetSystemEncoding() );        HSetState(stringH, s);    }    return result;}static CFStringRef ReadMachineNameFromFile(void){    CFStringRef     result;    CFURLRef        url;    CFDataRef       data;    CFDictionaryRef dict;    CFDictionaryRef systemDict;    CFDictionaryRef system2Dict;        result = nil;    url = CFURLCreateWithFileSystemPath(kCFAllocatorDefault,                     CFSTR("/var/db/SystemConfiguration/preferences.xml"),                     kCFURLPOSIXPathStyle,                     false );    if (url != nil) {        if ( CFURLCreateDataAndPropertiesFromResource(kCFAllocatorDefault,                                        url, &data, nil, nil, nil ) ) {            dict = (CFDictionaryRef)CFPropertyListCreateFromXMLData(kCFAllocatorSystemDefault,                                        data, kCFPropertyListImmutable, nil);            if (dict != nil) {                systemDict = (CFDictionaryRef)CFDictionaryGetValue(dict, CFSTR("System") );                if (systemDict != nil) {                    system2Dict = (CFDictionaryRef)CFDictionaryGetValue(systemDict,                                                       CFSTR("System") );                    if ( system2Dict != nil ) {                        result = (CFStringRef)CFDictionaryGetValue(system2Dict,                                                       CFSTR("ComputerName") );                        if (result != nil) {                            CFRetain(result);                        }                    }                }                CFRelease(dict);            }            CFRelease( data );        }        CFRelease( url );    }    return result;}static pascal CFStringRef MoreCSCopyUserName(Boolean useShortName)    // See comment in header file.{    CFStringRef result;    if ( gMoreCSSystemVersion == 0 ) {        (void) Gestalt(gestaltSystemVersion, (SInt32 *) &gMoreCSSystemVersion);    }    if ( gMoreCSSystemVersion < kMoreCSMacOSX10point0 ) {        // Running on traditional Mac OS.  If we have a recent version        // of CarbonLib (1.5 and above) that supports the routine, use        // that.  Otherwise fall back to the Resource Manager.        if ( CSCopyUserName != (void *) kUnresolvedCFragSymbolAddress) {            result = CSCopyUserName(useShortName);        } else {            result = CreateCFStringFromStringResource(-16096);        }    } else {        // Call the API.  However, if we're built CFM we can't just        // call it directly because the routine isn't exported to        // CFM on Mac OS 10.0.x.  So for CFM builds we have to call        // through CFBundle.        #if TARGET_RT_MAC_CFM            {                typedef CFStringRef (*CSCopyUserNameProc)(Boolean useShortName);                CSCopyUserNameProc  csCopyUserName;                CFBundleRef         bundle;                result = nil;                csCopyUserName = nil;                bundle = CFBundleGetBundleWithIdentifier(                                                 CFSTR("com.apple.Carbon" ) );                if (bundle != nil) {                    csCopyUserName =                       (CSCopyUserNameProc) CFBundleGetFunctionPointerForName(                                              bundle, CFSTR("CSCopyUserName") );                }                if (csCopyUserName != nil) {                    result = csCopyUserName(useShortName);                }                // Both bundle and csCopyUserName got with "Get", so                // no need to release.            }        #elif TARGET_RT_MAC_MACHO            result = CSCopyUserName(useShortName);        #else            #error MoreCSCopyUserName: What runtime are you using?        #endif        // Mac OS 10.0 and 10.0.1 (which have the same gestaltSystemVersion        // result -- this just gets better and better) have a bug [2665708]        // where they fail to retain the user name and host name strings        // each time they return it to the client.  The upshot is that        // the client crashes the second time it calls CSCopyUserName or        // CSCopyMachineName.  This extra CFRetain prevents this from happening.        //        // Note that we don't need a similar workaround in MoreCSCopyMachineName        // because we never call the CSCopyMachineName on 10.0 or 10.0.1        // because of another issue.        if (result != nil && gMoreCSSystemVersion == kMoreCSMacOSX10point0) {            CFRetain(result);        }    }    return result;}static pascal CFStringRef MoreCSCopyMachineName(void){    CFStringRef result;    if ( gMoreCSSystemVersion == 0 ) {        (void) Gestalt(gestaltSystemVersion, (SInt32 *) &gMoreCSSystemVersion);    }    if ( gMoreCSSystemVersion < kMoreCSMacOSX10point0 ) {        if ( CSCopyMachineName != (void *) kUnresolvedCFragSymbolAddress) {            result = CSCopyMachineName();        } else {            result = CreateCFStringFromStringResource(-16413);        }    } else if ( gMoreCSSystemVersion < kMoreCSMacOSX10point1 ) {        result = ReadMachineNameFromFile();    } else if ( gMoreCSSystemVersion < kMoreCSMacOSX10point2 ){        if ( CSCopyMachineName == (void *) kUnresolvedCFragSymbolAddress ) {            result = nil;        } else {            result = CSCopyMachineName();        }    } else {    	    }    return result;}#endif#pragma mark -#pragma mark *** Misc Functions ***char * getUserName(){	static char buf[256] = {0};		#ifdef TARGET_MAC_CARBON	CFStringRef string = MoreCSCopyUserName(0);	if(string == nil)		strcpy(buf, "Computer Name Unknown");	else		CFStringGetCString(string, buf, 256, kCFStringEncodingASCII);	if(*buf == 0)		strcpy(buf, "Computer Name Unknown");	#endif		#ifdef TARGET_WINDOWS	DWORD size = 256;	GetUserName(buf, &size);	#endif		return buf;}char * getComputerName(){	static char buf[256] = {0};		#ifdef TARGET_MAC_CARBON	CFStringRef string = MoreCSCopyMachineName();	if(string == nil)		strcpy(buf, "Computer Name Unknown");	else		CFStringGetCString(string, buf, 256, kCFStringEncodingASCII);	if(*buf == 0)		strcpy(buf, "Computer Name Unknown");	#endif		#ifdef TARGET_WINDOWS	DWORD size = 256;	GetComputerName(buf, &size);	#endif		return buf;}